{"ast":null,"code":"'use strict';\n\nvar react = require('react');\nvar vanilla = require('jotai/vanilla');\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar SUSPENSE_PROMISE = Symbol();\nvar isSuspensePromise = function isSuspensePromise(promise) {\n  return !!promise[SUSPENSE_PROMISE];\n};\nvar isSuspensePromiseAlreadyCancelled = function isSuspensePromiseAlreadyCancelled(suspensePromise) {\n  return !suspensePromise[SUSPENSE_PROMISE].c;\n};\nvar cancelSuspensePromise = function cancelSuspensePromise(suspensePromise) {\n  var _suspensePromise$SUSP = suspensePromise[SUSPENSE_PROMISE],\n    basePromise = _suspensePromise$SUSP.b,\n    cancelPromise = _suspensePromise$SUSP.c;\n  if (cancelPromise) {\n    var _promiseAbortMap$get;\n    cancelPromise();\n    (_promiseAbortMap$get = promiseAbortMap.get(basePromise)) == null ? void 0 : _promiseAbortMap$get();\n  }\n};\nvar isEqualSuspensePromise = function isEqualSuspensePromise(oldSuspensePromise, newSuspensePromise) {\n  var oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  var newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nvar createSuspensePromise = function createSuspensePromise(basePromise, promise) {\n  var suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  var suspensePromise = new Promise(function (resolve) {\n    suspensePromiseExtra.c = function () {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nvar copySuspensePromise = function copySuspensePromise(suspensePromise) {\n  return createSuspensePromise(suspensePromise[SUSPENSE_PROMISE].b, suspensePromise[SUSPENSE_PROMISE].o);\n};\nvar promiseAbortMap = new WeakMap();\nvar registerPromiseAbort = function registerPromiseAbort(basePromise, abort) {\n  promiseAbortMap.set(basePromise, abort);\n};\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar COMMIT_ATOM = 'c';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_SUBSCRIBE_STATE = 'n';\nvar DEV_GET_MOUNTED_ATOMS = 'l';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\nvar createStore = function createStore(initialValues) {\n  var _ref4;\n  var committedAtomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n  if (process.env.NODE_ENV !== \"production\") {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n        atom = _step$value[0],\n        value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        d: new Map()\n      };\n      if (process.env.NODE_ENV !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  var suspensePromiseCacheMap = new WeakMap();\n  var addSuspensePromiseToCache = function addSuspensePromiseToCache(version, atom, suspensePromise) {\n    var cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(function () {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  var cancelAllSuspensePromiseInCache = function cancelAllSuspensePromiseInCache(atom) {\n    var versionSet = new Set();\n    var cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach(function (suspensePromise, version) {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  var versionedAtomStateMapMap = new WeakMap();\n  var getVersionedAtomStateMap = function getVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  var getAtomState = function getAtomState(version, atom) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      var _atomState = versionedAtomStateMap.get(atom);\n      if (!_atomState) {\n        _atomState = getAtomState(version.p, atom);\n        if (_atomState && 'p' in _atomState && isSuspensePromiseAlreadyCancelled(_atomState.p)) {\n          _atomState = undefined;\n        }\n        if (_atomState) {\n          versionedAtomStateMap.set(atom, _atomState);\n        }\n      }\n      return _atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  var setAtomState = function setAtomState(version, atom, atomState) {\n    if (process.env.NODE_ENV !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      var prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  var createReadDependencies = function createReadDependencies(version, prevReadDependencies, dependencies) {\n    if (prevReadDependencies === void 0) {\n      prevReadDependencies = new Map();\n    }\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    var readDependencies = new Map();\n    var changed = false;\n    dependencies.forEach(function (atom) {\n      var _getAtomState;\n      var revision = ((_getAtomState = getAtomState(version, atom)) == null ? void 0 : _getAtomState.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  var setAtomValue = function setAtomValue(version, atom, value, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!('p' in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if ('p' in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    var nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    var changed = !(atomState != null && atomState.y);\n    if (!atomState || !('v' in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every(function (a) {\n      return atomState.d.has(a);\n    }))) {\n      changed = true;\n      Promise.resolve().then(function () {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomReadError = function setAtomReadError(version, atom, error, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!('p' in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if ('p' in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    var nextAtomState = {\n      e: error,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomSuspensePromise = function setAtomSuspensePromise(version, atom, suspensePromise, dependencies) {\n    var atomState = getAtomState(version, atom);\n    if (atomState && 'p' in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return _extends({}, atomState, {\n            y: true\n          });\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    var nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomPromiseOrValue = function setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies) {\n    if (promiseOrValue instanceof Promise) {\n      var suspensePromise = createSuspensePromise(promiseOrValue, promiseOrValue.then(function (value) {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n      }).catch(function (e) {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(function () {\n              readAtomState(version, atom, true);\n            });\n          }\n          return e;\n        }\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n  var setAtomInvalidated = function setAtomInvalidated(version, atom) {\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      var nextAtomState = _extends({}, atomState, {\n        y: false\n      });\n      setAtomState(version, atom, nextAtomState);\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[Bug] could not invalidate non existing atom', atom);\n    }\n  };\n  var readAtomState = function readAtomState(version, atom, force) {\n    if (!force) {\n      var _atomState2 = getAtomState(version, atom);\n      if (_atomState2) {\n        if (_atomState2.y && 'p' in _atomState2 && !isSuspensePromiseAlreadyCancelled(_atomState2.p)) {\n          return _atomState2;\n        }\n        _atomState2.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              var aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(_atomState2.d).every(function (_ref) {\n          var a = _ref[0],\n            r = _ref[1];\n          var aState = getAtomState(version, a);\n          return aState && !('p' in aState) && aState.r === r;\n        })) {\n          if (!_atomState2.y) {\n            return _extends({}, _atomState2, {\n              y: true\n            });\n          }\n          return _atomState2;\n        }\n      }\n    }\n    var dependencies = new Set();\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if ('e' in aState) {\n            throw aState.e;\n          }\n          if ('p' in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error('no atom init');\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        var suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  var readAtom = function readAtom(readingAtom, version) {\n    var atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  var addAtom = function addAtom(version, addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n  var delAtom = function delAtom(version, deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  var invalidateDependents = function invalidateDependents(version, atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(function (dependent) {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  var writeAtomState = function writeAtomState(version, atom, update) {\n    var isSync = true;\n    var writeGetter = function writeGetter(a, options) {\n      var aState = readAtomState(version, a);\n      if ('e' in aState) {\n        throw aState.e;\n      }\n      if ('p' in aState) {\n        if (options != null && options.unstable_promise) {\n          return aState.p.then(function () {\n            var s = getAtomState(version, a);\n            if (s && 'p' in s && s.p === aState.p) {\n              return new Promise(function (resolve) {\n                return setTimeout(resolve);\n              }).then(function () {\n                return writeGetter(a, options);\n              });\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n          console.info('Reading pending atom state in write operation. We throw a promise for now.', a);\n        }\n        throw aState.p;\n      }\n      if ('v' in aState) {\n        return aState.v;\n      }\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n      throw new Error('no value found');\n    };\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('atom not writable');\n        }\n        var versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach(function (cancelledVersion) {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        var prevAtomState = getAtomState(version, a);\n        var nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid;\n    };\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  var writeAtom = function writeAtom(writingAtom, update, version) {\n    var promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n  var mountAtom = function mountAtom(version, atom, initialDependent) {\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (process.env.NODE_ENV !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    var atomState = readAtomState(undefined, atom);\n    atomState.d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update, version);\n      };\n      var onUnmount = atom.onMount(setAtom);\n      version = undefined;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  var unmountAtom = function unmountAtom(version, atom) {\n    var _mountedMap$get;\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (process.env.NODE_ENV !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      if ('p' in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n  var mountDependencies = function mountDependencies(version, atom, atomState, prevReadDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  var flushPending = function flushPending(version) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach(function (atomState, atom) {\n        var committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          var mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n            return listener(version);\n          });\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      var pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(function (_ref2) {\n        var atom = _ref2[0],\n          prevAtomState = _ref2[1];\n        var atomState = getAtomState(undefined, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(undefined, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && atomState != null && atomState.y) {\n          return;\n        }\n        var mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n          return listener();\n        });\n      });\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      stateListeners.forEach(function (l) {\n        return l();\n      });\n    }\n  };\n  var commitVersionedAtomStateMap = function commitVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach(function (atomState, atom) {\n      var prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  var commitAtom = function commitAtom(_atom, version) {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(undefined);\n  };\n  var subscribeAtom = function subscribeAtom(atom, callback, version) {\n    var mounted = addAtom(version, atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  var restoreAtoms = function restoreAtoms(values, version) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n        _atom2 = _step2$value[0],\n        _value = _step2$value[1];\n      if (hasInitialValue(_atom2)) {\n        setAtomPromiseOrValue(version, _atom2, _value);\n        invalidateDependents(version, _atom2);\n      }\n    }\n    flushPending(version);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    var _ref3;\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[COMMIT_ATOM] = commitAtom, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_SUBSCRIBE_STATE] = function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }, _ref3[DEV_GET_MOUNTED_ATOMS] = function () {\n      return mountedAtoms.values();\n    }, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return committedAtomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[COMMIT_ATOM] = commitAtom, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\nvar createStoreForExport = function createStoreForExport(initialValues) {\n  var store = createStore(initialValues);\n  var get = function get(atom) {\n    var atomState = store[READ_ATOM](atom);\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n    if ('p' in atomState) {\n      return undefined;\n    }\n    return atomState.v;\n  };\n  var asyncGet = function asyncGet(atom) {\n    return new Promise(function (resolve, reject) {\n      var atomState = store[READ_ATOM](atom);\n      if ('e' in atomState) {\n        reject(atomState.e);\n      } else if ('p' in atomState) {\n        resolve(atomState.p.then(function () {\n          return asyncGet(atom);\n        }));\n      } else {\n        resolve(atomState.v);\n      }\n    });\n  };\n  var set = function set(atom, update) {\n    return store[WRITE_ATOM](atom, update);\n  };\n  var sub = function sub(atom, callback) {\n    return store[SUBSCRIBE_ATOM](atom, callback);\n  };\n  return {\n    get: get,\n    asyncGet: asyncGet,\n    set: set,\n    sub: sub,\n    SECRET_INTERNAL_store: store\n  };\n};\nvar createScopeContainer = function createScopeContainer(initialValues, unstable_createStore) {\n  var store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return {\n    s: store\n  };\n};\nvar ScopeContextMap = new Map();\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\nvar Provider = function Provider(_ref) {\n  var children = _ref.children,\n    initialValues = _ref.initialValues,\n    scope = _ref.scope,\n    unstable_createStore = _ref.unstable_createStore,\n    unstable_enableVersionedWrite = _ref.unstable_enableVersionedWrite;\n  var _useState = react.useState({}),\n    version = _useState[0],\n    setVersion = _useState[1];\n  react.useEffect(function () {\n    var scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  var scopeContainerRef = react.useRef();\n  if (!scopeContainerRef.current) {\n    var scopeContainer = createScopeContainer(initialValues, unstable_createStore);\n    if (unstable_enableVersionedWrite) {\n      var retrying = 0;\n      scopeContainer.w = function (write) {\n        setVersion(function (parentVersion) {\n          var nextVersion = retrying ? parentVersion : {\n            p: parentVersion\n          };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = function (fn) {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\nfunction atom(read, write) {\n  return vanilla.atom(read, write);\n}\nfunction useAtomValue(atom, scope) {\n  var ScopeContext = getScopeContext(scope);\n  var scopeContainer = react.useContext(ScopeContext);\n  var store = scopeContainer.s,\n    versionFromProvider = scopeContainer.v;\n  var getAtomValue = function getAtomValue(version) {\n    var atomState = store[READ_ATOM](atom, version);\n    if (process.env.NODE_ENV !== \"production\" && !atomState.y) {\n      throw new Error('should not be invalidated');\n    }\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n    if ('p' in atomState) {\n      throw atomState.p;\n    }\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n    throw new Error('no atom value');\n  };\n  var _useReducer = react.useReducer(function (prev, nextVersion) {\n      var nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    }, versionFromProvider, function (initialVersion) {\n      var initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }),\n    _useReducer$ = _useReducer[0],\n    version = _useReducer$[0],\n    valueFromReducer = _useReducer$[1],\n    atomFromReducer = _useReducer$[2],\n    rerenderIfChanged = _useReducer[1];\n  var value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  react.useEffect(function () {\n    var versionFromProvider = scopeContainer.v;\n    if (versionFromProvider) {\n      store[COMMIT_ATOM](atom, versionFromProvider);\n    }\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged, versionFromProvider);\n    rerenderIfChanged(versionFromProvider);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  react.useEffect(function () {\n    store[COMMIT_ATOM](atom, version);\n  });\n  react.useDebugValue(value);\n  return value;\n}\nfunction useSetAtom(atom, scope) {\n  var ScopeContext = getScopeContext(scope);\n  var _useContext = react.useContext(ScopeContext),\n    store = _useContext.s,\n    versionedWrite = _useContext.w;\n  var setAtom = react.useCallback(function (update) {\n    if (process.env.NODE_ENV !== \"production\" && !('write' in atom)) {\n      throw new Error('not writable atom');\n    }\n    var write = function write(version) {\n      return store[WRITE_ATOM](atom, update, version);\n    };\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n  return [useAtomValue(atom, scope), useSetAtom(atom, scope)];\n}\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.SECRET_INTERNAL_registerPromiseAbort = registerPromiseAbort;\nexports.atom = atom;\nexports.unstable_createStore = createStoreForExport;\nexports.useAtom = useAtom;\nexports.useAtomValue = useAtomValue;\nexports.useSetAtom = useSetAtom;","map":{"version":3,"names":["react","require","vanilla","_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","toString","slice","constructor","name","Array","from","test","arr","len","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","Symbol","iterator","next","isArray","done","value","TypeError","SUSPENSE_PROMISE","isSuspensePromise","promise","isSuspensePromiseAlreadyCancelled","suspensePromise","c","cancelSuspensePromise","_suspensePromise$SUSP","basePromise","b","cancelPromise","_promiseAbortMap$get","promiseAbortMap","get","isEqualSuspensePromise","oldSuspensePromise","newSuspensePromise","oldOriginalPromise","newOriginalPromise","createSuspensePromise","suspensePromiseExtra","Promise","resolve","finally","copySuspensePromise","WeakMap","registerPromiseAbort","abort","set","hasInitialValue","atom","READ_ATOM","WRITE_ATOM","COMMIT_ATOM","SUBSCRIBE_ATOM","RESTORE_ATOMS","DEV_SUBSCRIBE_STATE","DEV_GET_MOUNTED_ATOMS","DEV_GET_ATOM_STATE","DEV_GET_MOUNTED","createStore","initialValues","_ref4","committedAtomStateMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","process","env","NODE_ENV","Set","_iterator","_step","_step$value","atomState","v","r","y","d","freeze","console","warn","suspensePromiseCacheMap","addSuspensePromiseToCache","version","cache","then","delete","size","cancelAllSuspensePromiseInCache","versionSet","forEach","add","versionedAtomStateMapMap","getVersionedAtomStateMap","versionedAtomStateMap","getAtomState","_atomState","p","undefined","setAtomState","prevAtomState","has","createReadDependencies","prevReadDependencies","dependencies","readDependencies","changed","_getAtomState","revision","setAtomValue","nextAtomState","is","keys","every","a","flushPending","setAtomReadError","error","e","setAtomSuspensePromise","setAtomPromiseOrValue","promiseOrValue","catch","readAtomState","setAtomInvalidated","force","_atomState2","_","aState","_ref","read","init","Error","errorOrPromise","readAtom","readingAtom","addAtom","addingAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","deletingAtom","unmountAtom","invalidateDependents","dependent","writeAtomState","update","isSync","writeGetter","options","unstable_promise","s","setTimeout","info","setter","promiseOrVoid","cancelledVersion","write","writeAtom","writingAtom","isActuallyWritableAtom","initialDependent","aMounted","onMount","setAtom","onUnmount","u","_mountedMap$get","mountDependencies","committedAtomState","listener","pending","clear","_ref2","commitVersionedAtomStateMap","commitAtom","_atom","subscribeAtom","callback","listeners","restoreAtoms","values","_iterator2","_step2","_step2$value","_atom2","_value","_ref3","createStoreForExport","store","asyncGet","reject","sub","SECRET_INTERNAL_store","createScopeContainer","unstable_createStore","ScopeContextMap","getScopeContext","scope","createContext","Provider","children","unstable_enableVersionedWrite","_useState","useState","setVersion","useEffect","scopeContainer","scopeContainerRef","current","w","useRef","retrying","parentVersion","nextVersion","fn","ScopeContainerContext","createElement","useAtomValue","ScopeContext","useContext","versionFromProvider","getAtomValue","_useReducer","useReducer","prev","nextValue","initialVersion","initialValue","_useReducer$","valueFromReducer","atomFromReducer","rerenderIfChanged","unsubscribe","useDebugValue","useSetAtom","_useContext","versionedWrite","useCallback","useAtom","exports","SECRET_INTERNAL_getScopeContext","SECRET_INTERNAL_registerPromiseAbort"],"sources":["/Users/jeonghoyeo/toy/monad_games/game01/static/node_modules/jotai/index.js"],"sourcesContent":["'use strict';\n\nvar react = require('react');\nvar vanilla = require('jotai/vanilla');\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar SUSPENSE_PROMISE = Symbol();\nvar isSuspensePromise = function isSuspensePromise(promise) {\n  return !!promise[SUSPENSE_PROMISE];\n};\nvar isSuspensePromiseAlreadyCancelled = function isSuspensePromiseAlreadyCancelled(suspensePromise) {\n  return !suspensePromise[SUSPENSE_PROMISE].c;\n};\nvar cancelSuspensePromise = function cancelSuspensePromise(suspensePromise) {\n  var _suspensePromise$SUSP = suspensePromise[SUSPENSE_PROMISE],\n    basePromise = _suspensePromise$SUSP.b,\n    cancelPromise = _suspensePromise$SUSP.c;\n  if (cancelPromise) {\n    var _promiseAbortMap$get;\n    cancelPromise();\n    (_promiseAbortMap$get = promiseAbortMap.get(basePromise)) == null ? void 0 : _promiseAbortMap$get();\n  }\n};\nvar isEqualSuspensePromise = function isEqualSuspensePromise(oldSuspensePromise, newSuspensePromise) {\n  var oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;\n  var newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;\n  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);\n};\nvar createSuspensePromise = function createSuspensePromise(basePromise, promise) {\n  var suspensePromiseExtra = {\n    b: basePromise,\n    o: promise,\n    c: null\n  };\n  var suspensePromise = new Promise(function (resolve) {\n    suspensePromiseExtra.c = function () {\n      suspensePromiseExtra.c = null;\n      resolve();\n    };\n    promise.finally(suspensePromiseExtra.c);\n  });\n  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;\n  return suspensePromise;\n};\nvar copySuspensePromise = function copySuspensePromise(suspensePromise) {\n  return createSuspensePromise(suspensePromise[SUSPENSE_PROMISE].b, suspensePromise[SUSPENSE_PROMISE].o);\n};\nvar promiseAbortMap = new WeakMap();\nvar registerPromiseAbort = function registerPromiseAbort(basePromise, abort) {\n  promiseAbortMap.set(basePromise, abort);\n};\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\nvar READ_ATOM = 'r';\nvar WRITE_ATOM = 'w';\nvar COMMIT_ATOM = 'c';\nvar SUBSCRIBE_ATOM = 's';\nvar RESTORE_ATOMS = 'h';\nvar DEV_SUBSCRIBE_STATE = 'n';\nvar DEV_GET_MOUNTED_ATOMS = 'l';\nvar DEV_GET_ATOM_STATE = 'a';\nvar DEV_GET_MOUNTED = 'm';\nvar createStore = function createStore(initialValues) {\n  var _ref4;\n  var committedAtomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n  if (process.env.NODE_ENV !== \"production\") {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n  if (initialValues) {\n    for (var _iterator = _createForOfIteratorHelperLoose(initialValues), _step; !(_step = _iterator()).done;) {\n      var _step$value = _step.value,\n        atom = _step$value[0],\n        value = _step$value[1];\n      var atomState = {\n        v: value,\n        r: 0,\n        y: true,\n        d: new Map()\n      };\n      if (process.env.NODE_ENV !== \"production\") {\n        Object.freeze(atomState);\n        if (!hasInitialValue(atom)) {\n          console.warn('Found initial value for derived atom which can cause unexpected behavior', atom);\n        }\n      }\n      committedAtomStateMap.set(atom, atomState);\n    }\n  }\n  var suspensePromiseCacheMap = new WeakMap();\n  var addSuspensePromiseToCache = function addSuspensePromiseToCache(version, atom, suspensePromise) {\n    var cache = suspensePromiseCacheMap.get(atom);\n    if (!cache) {\n      cache = new Map();\n      suspensePromiseCacheMap.set(atom, cache);\n    }\n    suspensePromise.then(function () {\n      if (cache.get(version) === suspensePromise) {\n        cache.delete(version);\n        if (!cache.size) {\n          suspensePromiseCacheMap.delete(atom);\n        }\n      }\n    });\n    cache.set(version, suspensePromise);\n  };\n  var cancelAllSuspensePromiseInCache = function cancelAllSuspensePromiseInCache(atom) {\n    var versionSet = new Set();\n    var cache = suspensePromiseCacheMap.get(atom);\n    if (cache) {\n      suspensePromiseCacheMap.delete(atom);\n      cache.forEach(function (suspensePromise, version) {\n        cancelSuspensePromise(suspensePromise);\n        versionSet.add(version);\n      });\n    }\n    return versionSet;\n  };\n  var versionedAtomStateMapMap = new WeakMap();\n  var getVersionedAtomStateMap = function getVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = versionedAtomStateMapMap.get(version);\n    if (!versionedAtomStateMap) {\n      versionedAtomStateMap = new Map();\n      versionedAtomStateMapMap.set(version, versionedAtomStateMap);\n    }\n    return versionedAtomStateMap;\n  };\n  var getAtomState = function getAtomState(version, atom) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      var _atomState = versionedAtomStateMap.get(atom);\n      if (!_atomState) {\n        _atomState = getAtomState(version.p, atom);\n        if (_atomState && 'p' in _atomState && isSuspensePromiseAlreadyCancelled(_atomState.p)) {\n          _atomState = undefined;\n        }\n        if (_atomState) {\n          versionedAtomStateMap.set(atom, _atomState);\n        }\n      }\n      return _atomState;\n    }\n    return committedAtomStateMap.get(atom);\n  };\n  var setAtomState = function setAtomState(version, atom, atomState) {\n    if (process.env.NODE_ENV !== \"production\") {\n      Object.freeze(atomState);\n    }\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.set(atom, atomState);\n    } else {\n      var prevAtomState = committedAtomStateMap.get(atom);\n      committedAtomStateMap.set(atom, atomState);\n      if (!pendingMap.has(atom)) {\n        pendingMap.set(atom, prevAtomState);\n      }\n    }\n  };\n  var createReadDependencies = function createReadDependencies(version, prevReadDependencies, dependencies) {\n    if (prevReadDependencies === void 0) {\n      prevReadDependencies = new Map();\n    }\n    if (!dependencies) {\n      return prevReadDependencies;\n    }\n    var readDependencies = new Map();\n    var changed = false;\n    dependencies.forEach(function (atom) {\n      var _getAtomState;\n      var revision = ((_getAtomState = getAtomState(version, atom)) == null ? void 0 : _getAtomState.r) || 0;\n      readDependencies.set(atom, revision);\n      if (prevReadDependencies.get(atom) !== revision) {\n        changed = true;\n      }\n    });\n    if (prevReadDependencies.size === readDependencies.size && !changed) {\n      return prevReadDependencies;\n    }\n    return readDependencies;\n  };\n  var setAtomValue = function setAtomValue(version, atom, value, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!('p' in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if ('p' in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    var nextAtomState = {\n      v: value,\n      r: (atomState == null ? void 0 : atomState.r) || 0,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    var changed = !(atomState != null && atomState.y);\n    if (!atomState || !('v' in atomState) || !Object.is(atomState.v, value)) {\n      changed = true;\n      ++nextAtomState.r;\n      if (nextAtomState.d.has(atom)) {\n        nextAtomState.d = new Map(nextAtomState.d).set(atom, nextAtomState.r);\n      }\n    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every(function (a) {\n      return atomState.d.has(a);\n    }))) {\n      changed = true;\n      Promise.resolve().then(function () {\n        flushPending(version);\n      });\n    }\n    if (atomState && !changed) {\n      return atomState;\n    }\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomReadError = function setAtomReadError(version, atom, error, dependencies, suspensePromise) {\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      if (suspensePromise && (!('p' in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {\n        return atomState;\n      }\n      if ('p' in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n    }\n    var nextAtomState = {\n      e: error,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomSuspensePromise = function setAtomSuspensePromise(version, atom, suspensePromise, dependencies) {\n    var atomState = getAtomState(version, atom);\n    if (atomState && 'p' in atomState) {\n      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {\n        if (!atomState.y) {\n          return _extends({}, atomState, {\n            y: true\n          });\n        }\n        return atomState;\n      }\n      cancelSuspensePromise(atomState.p);\n    }\n    addSuspensePromiseToCache(version, atom, suspensePromise);\n    var nextAtomState = {\n      p: suspensePromise,\n      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,\n      y: true,\n      d: createReadDependencies(version, atomState == null ? void 0 : atomState.d, dependencies)\n    };\n    setAtomState(version, atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomPromiseOrValue = function setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies) {\n    if (promiseOrValue instanceof Promise) {\n      var suspensePromise = createSuspensePromise(promiseOrValue, promiseOrValue.then(function (value) {\n        setAtomValue(version, atom, value, dependencies, suspensePromise);\n      }).catch(function (e) {\n        if (e instanceof Promise) {\n          if (isSuspensePromise(e)) {\n            return e.then(function () {\n              readAtomState(version, atom, true);\n            });\n          }\n          return e;\n        }\n        setAtomReadError(version, atom, e, dependencies, suspensePromise);\n      }));\n      return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n    }\n    return setAtomValue(version, atom, promiseOrValue, dependencies);\n  };\n  var setAtomInvalidated = function setAtomInvalidated(version, atom) {\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      var nextAtomState = _extends({}, atomState, {\n        y: false\n      });\n      setAtomState(version, atom, nextAtomState);\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[Bug] could not invalidate non existing atom', atom);\n    }\n  };\n  var readAtomState = function readAtomState(version, atom, force) {\n    if (!force) {\n      var _atomState2 = getAtomState(version, atom);\n      if (_atomState2) {\n        if (_atomState2.y && 'p' in _atomState2 && !isSuspensePromiseAlreadyCancelled(_atomState2.p)) {\n          return _atomState2;\n        }\n        _atomState2.d.forEach(function (_, a) {\n          if (a !== atom) {\n            if (!mountedMap.has(a)) {\n              readAtomState(version, a);\n            } else {\n              var aState = getAtomState(version, a);\n              if (aState && !aState.y) {\n                readAtomState(version, a);\n              }\n            }\n          }\n        });\n        if (Array.from(_atomState2.d).every(function (_ref) {\n          var a = _ref[0],\n            r = _ref[1];\n          var aState = getAtomState(version, a);\n          return aState && !('p' in aState) && aState.r === r;\n        })) {\n          if (!_atomState2.y) {\n            return _extends({}, _atomState2, {\n              y: true\n            });\n          }\n          return _atomState2;\n        }\n      }\n    }\n    var dependencies = new Set();\n    try {\n      var promiseOrValue = atom.read(function (a) {\n        dependencies.add(a);\n        var aState = a === atom ? getAtomState(version, a) : readAtomState(version, a);\n        if (aState) {\n          if ('e' in aState) {\n            throw aState.e;\n          }\n          if ('p' in aState) {\n            throw aState.p;\n          }\n          return aState.v;\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error('no atom init');\n      });\n      return setAtomPromiseOrValue(version, atom, promiseOrValue, dependencies);\n    } catch (errorOrPromise) {\n      if (errorOrPromise instanceof Promise) {\n        var suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);\n        return setAtomSuspensePromise(version, atom, suspensePromise, dependencies);\n      }\n      return setAtomReadError(version, atom, errorOrPromise, dependencies);\n    }\n  };\n  var readAtom = function readAtom(readingAtom, version) {\n    var atomState = readAtomState(version, readingAtom);\n    return atomState;\n  };\n  var addAtom = function addAtom(version, addingAtom) {\n    var mounted = mountedMap.get(addingAtom);\n    if (!mounted) {\n      mounted = mountAtom(version, addingAtom);\n    }\n    return mounted;\n  };\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n  var delAtom = function delAtom(version, deletingAtom) {\n    var mounted = mountedMap.get(deletingAtom);\n    if (mounted && canUnmountAtom(deletingAtom, mounted)) {\n      unmountAtom(version, deletingAtom);\n    }\n  };\n  var invalidateDependents = function invalidateDependents(version, atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(function (dependent) {\n      if (dependent !== atom) {\n        setAtomInvalidated(version, dependent);\n        invalidateDependents(version, dependent);\n      }\n    });\n  };\n  var writeAtomState = function writeAtomState(version, atom, update) {\n    var isSync = true;\n    var writeGetter = function writeGetter(a, options) {\n      var aState = readAtomState(version, a);\n      if ('e' in aState) {\n        throw aState.e;\n      }\n      if ('p' in aState) {\n        if (options != null && options.unstable_promise) {\n          return aState.p.then(function () {\n            var s = getAtomState(version, a);\n            if (s && 'p' in s && s.p === aState.p) {\n              return new Promise(function (resolve) {\n                return setTimeout(resolve);\n              }).then(function () {\n                return writeGetter(a, options);\n              });\n            }\n            return writeGetter(a, options);\n          });\n        }\n        if (process.env.NODE_ENV !== \"production\") {\n          console.info('Reading pending atom state in write operation. We throw a promise for now.', a);\n        }\n        throw aState.p;\n      }\n      if ('v' in aState) {\n        return aState.v;\n      }\n      if (process.env.NODE_ENV !== \"production\") {\n        console.warn('[Bug] no value found while reading atom in write operation. This is probably a bug.', a);\n      }\n      throw new Error('no value found');\n    };\n    var setter = function setter(a, v) {\n      var promiseOrVoid;\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('atom not writable');\n        }\n        var versionSet = cancelAllSuspensePromiseInCache(a);\n        versionSet.forEach(function (cancelledVersion) {\n          if (cancelledVersion !== version) {\n            setAtomPromiseOrValue(cancelledVersion, a, v);\n          }\n        });\n        var prevAtomState = getAtomState(version, a);\n        var nextAtomState = setAtomPromiseOrValue(version, a, v);\n        if (prevAtomState !== nextAtomState) {\n          invalidateDependents(version, a);\n        }\n      } else {\n        promiseOrVoid = writeAtomState(version, a, v);\n      }\n      if (!isSync) {\n        flushPending(version);\n      }\n      return promiseOrVoid;\n    };\n    var promiseOrVoid = atom.write(writeGetter, setter, update);\n    isSync = false;\n    return promiseOrVoid;\n  };\n  var writeAtom = function writeAtom(writingAtom, update, version) {\n    var promiseOrVoid = writeAtomState(version, writingAtom, update);\n    flushPending(version);\n    return promiseOrVoid;\n  };\n  var isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n    return !!atom.write;\n  };\n  var mountAtom = function mountAtom(version, atom, initialDependent) {\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (process.env.NODE_ENV !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    var atomState = readAtomState(undefined, atom);\n    atomState.d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(version, a, atom);\n        }\n      }\n    });\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var setAtom = function setAtom(update) {\n        return writeAtom(atom, update, version);\n      };\n      var onUnmount = atom.onMount(setAtom);\n      version = undefined;\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  var unmountAtom = function unmountAtom(version, atom) {\n    var _mountedMap$get;\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (process.env.NODE_ENV !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    var atomState = getAtomState(version, atom);\n    if (atomState) {\n      if ('p' in atomState) {\n        cancelSuspensePromise(atomState.p);\n      }\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(version, a);\n            }\n          }\n        }\n      });\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n  var mountDependencies = function mountDependencies(version, atom, atomState, prevReadDependencies) {\n    var dependencies = new Set(atomState.d.keys());\n    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach(function (_, a) {\n      if (dependencies.has(a)) {\n        dependencies.delete(a);\n        return;\n      }\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(version, a);\n        }\n      }\n    });\n    dependencies.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(version, a, atom);\n      }\n    });\n  };\n  var flushPending = function flushPending(version) {\n    if (version) {\n      var versionedAtomStateMap = getVersionedAtomStateMap(version);\n      versionedAtomStateMap.forEach(function (atomState, atom) {\n        var committedAtomState = committedAtomStateMap.get(atom);\n        if (atomState !== committedAtomState) {\n          var mounted = mountedMap.get(atom);\n          mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n            return listener(version);\n          });\n        }\n      });\n      return;\n    }\n    while (pendingMap.size) {\n      var pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(function (_ref2) {\n        var atom = _ref2[0],\n          prevAtomState = _ref2[1];\n        var atomState = getAtomState(undefined, atom);\n        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(undefined, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n        if (prevAtomState && !prevAtomState.y && atomState != null && atomState.y) {\n          return;\n        }\n        var mounted = mountedMap.get(atom);\n        mounted == null ? void 0 : mounted.l.forEach(function (listener) {\n          return listener();\n        });\n      });\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      stateListeners.forEach(function (l) {\n        return l();\n      });\n    }\n  };\n  var commitVersionedAtomStateMap = function commitVersionedAtomStateMap(version) {\n    var versionedAtomStateMap = getVersionedAtomStateMap(version);\n    versionedAtomStateMap.forEach(function (atomState, atom) {\n      var prevAtomState = committedAtomStateMap.get(atom);\n      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {\n        committedAtomStateMap.set(atom, atomState);\n        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n          mountDependencies(version, atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n        }\n      }\n    });\n  };\n  var commitAtom = function commitAtom(_atom, version) {\n    if (version) {\n      commitVersionedAtomStateMap(version);\n    }\n    flushPending(undefined);\n  };\n  var subscribeAtom = function subscribeAtom(atom, callback, version) {\n    var mounted = addAtom(version, atom);\n    var listeners = mounted.l;\n    listeners.add(callback);\n    return function () {\n      listeners.delete(callback);\n      delAtom(version, atom);\n    };\n  };\n  var restoreAtoms = function restoreAtoms(values, version) {\n    for (var _iterator2 = _createForOfIteratorHelperLoose(values), _step2; !(_step2 = _iterator2()).done;) {\n      var _step2$value = _step2.value,\n        _atom2 = _step2$value[0],\n        _value = _step2$value[1];\n      if (hasInitialValue(_atom2)) {\n        setAtomPromiseOrValue(version, _atom2, _value);\n        invalidateDependents(version, _atom2);\n      }\n    }\n    flushPending(version);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    var _ref3;\n    return _ref3 = {}, _ref3[READ_ATOM] = readAtom, _ref3[WRITE_ATOM] = writeAtom, _ref3[COMMIT_ATOM] = commitAtom, _ref3[SUBSCRIBE_ATOM] = subscribeAtom, _ref3[RESTORE_ATOMS] = restoreAtoms, _ref3[DEV_SUBSCRIBE_STATE] = function (l) {\n      stateListeners.add(l);\n      return function () {\n        stateListeners.delete(l);\n      };\n    }, _ref3[DEV_GET_MOUNTED_ATOMS] = function () {\n      return mountedAtoms.values();\n    }, _ref3[DEV_GET_ATOM_STATE] = function (a) {\n      return committedAtomStateMap.get(a);\n    }, _ref3[DEV_GET_MOUNTED] = function (a) {\n      return mountedMap.get(a);\n    }, _ref3;\n  }\n  return _ref4 = {}, _ref4[READ_ATOM] = readAtom, _ref4[WRITE_ATOM] = writeAtom, _ref4[COMMIT_ATOM] = commitAtom, _ref4[SUBSCRIBE_ATOM] = subscribeAtom, _ref4[RESTORE_ATOMS] = restoreAtoms, _ref4;\n};\nvar createStoreForExport = function createStoreForExport(initialValues) {\n  var store = createStore(initialValues);\n  var get = function get(atom) {\n    var atomState = store[READ_ATOM](atom);\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n    if ('p' in atomState) {\n      return undefined;\n    }\n    return atomState.v;\n  };\n  var asyncGet = function asyncGet(atom) {\n    return new Promise(function (resolve, reject) {\n      var atomState = store[READ_ATOM](atom);\n      if ('e' in atomState) {\n        reject(atomState.e);\n      } else if ('p' in atomState) {\n        resolve(atomState.p.then(function () {\n          return asyncGet(atom);\n        }));\n      } else {\n        resolve(atomState.v);\n      }\n    });\n  };\n  var set = function set(atom, update) {\n    return store[WRITE_ATOM](atom, update);\n  };\n  var sub = function sub(atom, callback) {\n    return store[SUBSCRIBE_ATOM](atom, callback);\n  };\n  return {\n    get: get,\n    asyncGet: asyncGet,\n    set: set,\n    sub: sub,\n    SECRET_INTERNAL_store: store\n  };\n};\n\nvar createScopeContainer = function createScopeContainer(initialValues, unstable_createStore) {\n  var store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);\n  return {\n    s: store\n  };\n};\nvar ScopeContextMap = new Map();\nvar getScopeContext = function getScopeContext(scope) {\n  if (!ScopeContextMap.has(scope)) {\n    ScopeContextMap.set(scope, react.createContext(createScopeContainer()));\n  }\n  return ScopeContextMap.get(scope);\n};\n\nvar Provider = function Provider(_ref) {\n  var children = _ref.children,\n    initialValues = _ref.initialValues,\n    scope = _ref.scope,\n    unstable_createStore = _ref.unstable_createStore,\n    unstable_enableVersionedWrite = _ref.unstable_enableVersionedWrite;\n  var _useState = react.useState({}),\n    version = _useState[0],\n    setVersion = _useState[1];\n  react.useEffect(function () {\n    var scopeContainer = scopeContainerRef.current;\n    if (scopeContainer.w) {\n      scopeContainer.s[COMMIT_ATOM](null, version);\n      delete version.p;\n      scopeContainer.v = version;\n    }\n  }, [version]);\n  var scopeContainerRef = react.useRef();\n  if (!scopeContainerRef.current) {\n    var scopeContainer = createScopeContainer(initialValues, unstable_createStore);\n    if (unstable_enableVersionedWrite) {\n      var retrying = 0;\n      scopeContainer.w = function (write) {\n        setVersion(function (parentVersion) {\n          var nextVersion = retrying ? parentVersion : {\n            p: parentVersion\n          };\n          write(nextVersion);\n          return nextVersion;\n        });\n      };\n      scopeContainer.v = version;\n      scopeContainer.r = function (fn) {\n        ++retrying;\n        fn();\n        --retrying;\n      };\n    }\n    scopeContainerRef.current = scopeContainer;\n  }\n  var ScopeContainerContext = getScopeContext(scope);\n  return react.createElement(ScopeContainerContext.Provider, {\n    value: scopeContainerRef.current\n  }, children);\n};\n\nfunction atom(read, write) {\n  return vanilla.atom(read, write);\n}\n\nfunction useAtomValue(atom, scope) {\n  var ScopeContext = getScopeContext(scope);\n  var scopeContainer = react.useContext(ScopeContext);\n  var store = scopeContainer.s,\n    versionFromProvider = scopeContainer.v;\n  var getAtomValue = function getAtomValue(version) {\n    var atomState = store[READ_ATOM](atom, version);\n    if (process.env.NODE_ENV !== \"production\" && !atomState.y) {\n      throw new Error('should not be invalidated');\n    }\n    if ('e' in atomState) {\n      throw atomState.e;\n    }\n    if ('p' in atomState) {\n      throw atomState.p;\n    }\n    if ('v' in atomState) {\n      return atomState.v;\n    }\n    throw new Error('no atom value');\n  };\n  var _useReducer = react.useReducer(function (prev, nextVersion) {\n      var nextValue = getAtomValue(nextVersion);\n      if (Object.is(prev[1], nextValue) && prev[2] === atom) {\n        return prev;\n      }\n      return [nextVersion, nextValue, atom];\n    }, versionFromProvider, function (initialVersion) {\n      var initialValue = getAtomValue(initialVersion);\n      return [initialVersion, initialValue, atom];\n    }),\n    _useReducer$ = _useReducer[0],\n    version = _useReducer$[0],\n    valueFromReducer = _useReducer$[1],\n    atomFromReducer = _useReducer$[2],\n    rerenderIfChanged = _useReducer[1];\n  var value = valueFromReducer;\n  if (atomFromReducer !== atom) {\n    rerenderIfChanged(version);\n    value = getAtomValue(version);\n  }\n  react.useEffect(function () {\n    var versionFromProvider = scopeContainer.v;\n    if (versionFromProvider) {\n      store[COMMIT_ATOM](atom, versionFromProvider);\n    }\n    var unsubscribe = store[SUBSCRIBE_ATOM](atom, rerenderIfChanged, versionFromProvider);\n    rerenderIfChanged(versionFromProvider);\n    return unsubscribe;\n  }, [store, atom, scopeContainer]);\n  react.useEffect(function () {\n    store[COMMIT_ATOM](atom, version);\n  });\n  react.useDebugValue(value);\n  return value;\n}\n\nfunction useSetAtom(atom, scope) {\n  var ScopeContext = getScopeContext(scope);\n  var _useContext = react.useContext(ScopeContext),\n    store = _useContext.s,\n    versionedWrite = _useContext.w;\n  var setAtom = react.useCallback(function (update) {\n    if (process.env.NODE_ENV !== \"production\" && !('write' in atom)) {\n      throw new Error('not writable atom');\n    }\n    var write = function write(version) {\n      return store[WRITE_ATOM](atom, update, version);\n    };\n    return versionedWrite ? versionedWrite(write) : write();\n  }, [store, versionedWrite, atom]);\n  return setAtom;\n}\n\nfunction useAtom(atom, scope) {\n  if ('scope' in atom) {\n    console.warn('atom.scope is deprecated. Please do useAtom(atom, scope) instead.');\n    scope = atom.scope;\n  }\n  return [useAtomValue(atom, scope), useSetAtom(atom, scope)];\n}\n\nexports.Provider = Provider;\nexports.SECRET_INTERNAL_getScopeContext = getScopeContext;\nexports.SECRET_INTERNAL_registerPromiseAbort = registerPromiseAbort;\nexports.atom = atom;\nexports.unstable_createStore = createStoreForExport;\nexports.useAtom = useAtom;\nexports.useAtomValue = useAtomValue;\nexports.useSetAtom = useSetAtom;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC;AAC5B,IAAIC,OAAO,GAAGD,OAAO,CAAC,eAAe,CAAC;AAEtC,SAASE,QAAQA,CAAA,EAAG;EAClBA,QAAQ,GAAGC,MAAM,CAACC,MAAM,GAAGD,MAAM,CAACC,MAAM,CAACC,IAAI,CAAC,CAAC,GAAG,UAAUC,MAAM,EAAE;IAClE,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;MACzC,IAAIG,MAAM,GAAGF,SAAS,CAACD,CAAC,CAAC;MACzB,KAAK,IAAII,GAAG,IAAID,MAAM,EAAE;QACtB,IAAIP,MAAM,CAACS,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,MAAM,EAAEC,GAAG,CAAC,EAAE;UACrDL,MAAM,CAACK,GAAG,CAAC,GAAGD,MAAM,CAACC,GAAG,CAAC;QAC3B;MACF;IACF;IACA,OAAOL,MAAM;EACf,CAAC;EACD,OAAOJ,QAAQ,CAACa,KAAK,CAAC,IAAI,EAAEP,SAAS,CAAC;AACxC;AACA,SAASQ,2BAA2BA,CAACC,CAAC,EAAEC,MAAM,EAAE;EAC9C,IAAI,CAACD,CAAC,EAAE;EACR,IAAI,OAAOA,CAAC,KAAK,QAAQ,EAAE,OAAOE,iBAAiB,CAACF,CAAC,EAAEC,MAAM,CAAC;EAC9D,IAAIE,CAAC,GAAGjB,MAAM,CAACS,SAAS,CAACS,QAAQ,CAACP,IAAI,CAACG,CAAC,CAAC,CAACK,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;EACtD,IAAIF,CAAC,KAAK,QAAQ,IAAIH,CAAC,CAACM,WAAW,EAAEH,CAAC,GAAGH,CAAC,CAACM,WAAW,CAACC,IAAI;EAC3D,IAAIJ,CAAC,KAAK,KAAK,IAAIA,CAAC,KAAK,KAAK,EAAE,OAAOK,KAAK,CAACC,IAAI,CAACT,CAAC,CAAC;EACpD,IAAIG,CAAC,KAAK,WAAW,IAAI,0CAA0C,CAACO,IAAI,CAACP,CAAC,CAAC,EAAE,OAAOD,iBAAiB,CAACF,CAAC,EAAEC,MAAM,CAAC;AAClH;AACA,SAASC,iBAAiBA,CAACS,GAAG,EAAEC,GAAG,EAAE;EACnC,IAAIA,GAAG,IAAI,IAAI,IAAIA,GAAG,GAAGD,GAAG,CAACnB,MAAM,EAAEoB,GAAG,GAAGD,GAAG,CAACnB,MAAM;EACrD,KAAK,IAAIF,CAAC,GAAG,CAAC,EAAEuB,IAAI,GAAG,IAAIL,KAAK,CAACI,GAAG,CAAC,EAAEtB,CAAC,GAAGsB,GAAG,EAAEtB,CAAC,EAAE,EAAEuB,IAAI,CAACvB,CAAC,CAAC,GAAGqB,GAAG,CAACrB,CAAC,CAAC;EACrE,OAAOuB,IAAI;AACb;AACA,SAASC,+BAA+BA,CAACd,CAAC,EAAEe,cAAc,EAAE;EAC1D,IAAIC,EAAE,GAAG,OAAOC,MAAM,KAAK,WAAW,IAAIjB,CAAC,CAACiB,MAAM,CAACC,QAAQ,CAAC,IAAIlB,CAAC,CAAC,YAAY,CAAC;EAC/E,IAAIgB,EAAE,EAAE,OAAO,CAACA,EAAE,GAAGA,EAAE,CAACnB,IAAI,CAACG,CAAC,CAAC,EAAEmB,IAAI,CAAC/B,IAAI,CAAC4B,EAAE,CAAC;EAC9C,IAAIR,KAAK,CAACY,OAAO,CAACpB,CAAC,CAAC,KAAKgB,EAAE,GAAGjB,2BAA2B,CAACC,CAAC,CAAC,CAAC,IAAIe,cAAc,IAAIf,CAAC,IAAI,OAAOA,CAAC,CAACR,MAAM,KAAK,QAAQ,EAAE;IACpH,IAAIwB,EAAE,EAAEhB,CAAC,GAAGgB,EAAE;IACd,IAAI1B,CAAC,GAAG,CAAC;IACT,OAAO,YAAY;MACjB,IAAIA,CAAC,IAAIU,CAAC,CAACR,MAAM,EAAE,OAAO;QACxB6B,IAAI,EAAE;MACR,CAAC;MACD,OAAO;QACLA,IAAI,EAAE,KAAK;QACXC,KAAK,EAAEtB,CAAC,CAACV,CAAC,EAAE;MACd,CAAC;IACH,CAAC;EACH;EACA,MAAM,IAAIiC,SAAS,CAAC,uIAAuI,CAAC;AAC9J;AAEA,IAAIC,gBAAgB,GAAGP,MAAM,CAAC,CAAC;AAC/B,IAAIQ,iBAAiB,GAAG,SAASA,iBAAiBA,CAACC,OAAO,EAAE;EAC1D,OAAO,CAAC,CAACA,OAAO,CAACF,gBAAgB,CAAC;AACpC,CAAC;AACD,IAAIG,iCAAiC,GAAG,SAASA,iCAAiCA,CAACC,eAAe,EAAE;EAClG,OAAO,CAACA,eAAe,CAACJ,gBAAgB,CAAC,CAACK,CAAC;AAC7C,CAAC;AACD,IAAIC,qBAAqB,GAAG,SAASA,qBAAqBA,CAACF,eAAe,EAAE;EAC1E,IAAIG,qBAAqB,GAAGH,eAAe,CAACJ,gBAAgB,CAAC;IAC3DQ,WAAW,GAAGD,qBAAqB,CAACE,CAAC;IACrCC,aAAa,GAAGH,qBAAqB,CAACF,CAAC;EACzC,IAAIK,aAAa,EAAE;IACjB,IAAIC,oBAAoB;IACxBD,aAAa,CAAC,CAAC;IACf,CAACC,oBAAoB,GAAGC,eAAe,CAACC,GAAG,CAACL,WAAW,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAGG,oBAAoB,CAAC,CAAC;EACrG;AACF,CAAC;AACD,IAAIG,sBAAsB,GAAG,SAASA,sBAAsBA,CAACC,kBAAkB,EAAEC,kBAAkB,EAAE;EACnG,IAAIC,kBAAkB,GAAGF,kBAAkB,CAACf,gBAAgB,CAAC,CAACxB,CAAC;EAC/D,IAAI0C,kBAAkB,GAAGF,kBAAkB,CAAChB,gBAAgB,CAAC,CAACxB,CAAC;EAC/D,OAAOyC,kBAAkB,KAAKC,kBAAkB,IAAIH,kBAAkB,KAAKG,kBAAkB,IAAIjB,iBAAiB,CAACgB,kBAAkB,CAAC,IAAIH,sBAAsB,CAACG,kBAAkB,EAAED,kBAAkB,CAAC;AAC1M,CAAC;AACD,IAAIG,qBAAqB,GAAG,SAASA,qBAAqBA,CAACX,WAAW,EAAEN,OAAO,EAAE;EAC/E,IAAIkB,oBAAoB,GAAG;IACzBX,CAAC,EAAED,WAAW;IACdhC,CAAC,EAAE0B,OAAO;IACVG,CAAC,EAAE;EACL,CAAC;EACD,IAAID,eAAe,GAAG,IAAIiB,OAAO,CAAC,UAAUC,OAAO,EAAE;IACnDF,oBAAoB,CAACf,CAAC,GAAG,YAAY;MACnCe,oBAAoB,CAACf,CAAC,GAAG,IAAI;MAC7BiB,OAAO,CAAC,CAAC;IACX,CAAC;IACDpB,OAAO,CAACqB,OAAO,CAACH,oBAAoB,CAACf,CAAC,CAAC;EACzC,CAAC,CAAC;EACFD,eAAe,CAACJ,gBAAgB,CAAC,GAAGoB,oBAAoB;EACxD,OAAOhB,eAAe;AACxB,CAAC;AACD,IAAIoB,mBAAmB,GAAG,SAASA,mBAAmBA,CAACpB,eAAe,EAAE;EACtE,OAAOe,qBAAqB,CAACf,eAAe,CAACJ,gBAAgB,CAAC,CAACS,CAAC,EAAEL,eAAe,CAACJ,gBAAgB,CAAC,CAACxB,CAAC,CAAC;AACxG,CAAC;AACD,IAAIoC,eAAe,GAAG,IAAIa,OAAO,CAAC,CAAC;AACnC,IAAIC,oBAAoB,GAAG,SAASA,oBAAoBA,CAAClB,WAAW,EAAEmB,KAAK,EAAE;EAC3Ef,eAAe,CAACgB,GAAG,CAACpB,WAAW,EAAEmB,KAAK,CAAC;AACzC,CAAC;AAED,IAAIE,eAAe,GAAG,SAASA,eAAeA,CAACC,IAAI,EAAE;EACnD,OAAO,MAAM,IAAIA,IAAI;AACvB,CAAC;AACD,IAAIC,SAAS,GAAG,GAAG;AACnB,IAAIC,UAAU,GAAG,GAAG;AACpB,IAAIC,WAAW,GAAG,GAAG;AACrB,IAAIC,cAAc,GAAG,GAAG;AACxB,IAAIC,aAAa,GAAG,GAAG;AACvB,IAAIC,mBAAmB,GAAG,GAAG;AAC7B,IAAIC,qBAAqB,GAAG,GAAG;AAC/B,IAAIC,kBAAkB,GAAG,GAAG;AAC5B,IAAIC,eAAe,GAAG,GAAG;AACzB,IAAIC,WAAW,GAAG,SAASA,WAAWA,CAACC,aAAa,EAAE;EACpD,IAAIC,KAAK;EACT,IAAIC,qBAAqB,GAAG,IAAIlB,OAAO,CAAC,CAAC;EACzC,IAAImB,UAAU,GAAG,IAAInB,OAAO,CAAC,CAAC;EAC9B,IAAIoB,UAAU,GAAG,IAAIC,GAAG,CAAC,CAAC;EAC1B,IAAIC,cAAc;EAClB,IAAIC,YAAY;EAChB,IAAIC,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzCJ,cAAc,GAAG,IAAIK,GAAG,CAAC,CAAC;IAC1BJ,YAAY,GAAG,IAAII,GAAG,CAAC,CAAC;EAC1B;EACA,IAAIX,aAAa,EAAE;IACjB,KAAK,IAAIY,SAAS,GAAG/D,+BAA+B,CAACmD,aAAa,CAAC,EAAEa,KAAK,EAAE,CAAC,CAACA,KAAK,GAAGD,SAAS,CAAC,CAAC,EAAExD,IAAI,GAAG;MACxG,IAAI0D,WAAW,GAAGD,KAAK,CAACxD,KAAK;QAC3BgC,IAAI,GAAGyB,WAAW,CAAC,CAAC,CAAC;QACrBzD,KAAK,GAAGyD,WAAW,CAAC,CAAC,CAAC;MACxB,IAAIC,SAAS,GAAG;QACdC,CAAC,EAAE3D,KAAK;QACR4D,CAAC,EAAE,CAAC;QACJC,CAAC,EAAE,IAAI;QACPC,CAAC,EAAE,IAAId,GAAG,CAAC;MACb,CAAC;MACD,IAAIG,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzCzF,MAAM,CAACmG,MAAM,CAACL,SAAS,CAAC;QACxB,IAAI,CAAC3B,eAAe,CAACC,IAAI,CAAC,EAAE;UAC1BgC,OAAO,CAACC,IAAI,CAAC,0EAA0E,EAAEjC,IAAI,CAAC;QAChG;MACF;MACAa,qBAAqB,CAACf,GAAG,CAACE,IAAI,EAAE0B,SAAS,CAAC;IAC5C;EACF;EACA,IAAIQ,uBAAuB,GAAG,IAAIvC,OAAO,CAAC,CAAC;EAC3C,IAAIwC,yBAAyB,GAAG,SAASA,yBAAyBA,CAACC,OAAO,EAAEpC,IAAI,EAAE1B,eAAe,EAAE;IACjG,IAAI+D,KAAK,GAAGH,uBAAuB,CAACnD,GAAG,CAACiB,IAAI,CAAC;IAC7C,IAAI,CAACqC,KAAK,EAAE;MACVA,KAAK,GAAG,IAAIrB,GAAG,CAAC,CAAC;MACjBkB,uBAAuB,CAACpC,GAAG,CAACE,IAAI,EAAEqC,KAAK,CAAC;IAC1C;IACA/D,eAAe,CAACgE,IAAI,CAAC,YAAY;MAC/B,IAAID,KAAK,CAACtD,GAAG,CAACqD,OAAO,CAAC,KAAK9D,eAAe,EAAE;QAC1C+D,KAAK,CAACE,MAAM,CAACH,OAAO,CAAC;QACrB,IAAI,CAACC,KAAK,CAACG,IAAI,EAAE;UACfN,uBAAuB,CAACK,MAAM,CAACvC,IAAI,CAAC;QACtC;MACF;IACF,CAAC,CAAC;IACFqC,KAAK,CAACvC,GAAG,CAACsC,OAAO,EAAE9D,eAAe,CAAC;EACrC,CAAC;EACD,IAAImE,+BAA+B,GAAG,SAASA,+BAA+BA,CAACzC,IAAI,EAAE;IACnF,IAAI0C,UAAU,GAAG,IAAIpB,GAAG,CAAC,CAAC;IAC1B,IAAIe,KAAK,GAAGH,uBAAuB,CAACnD,GAAG,CAACiB,IAAI,CAAC;IAC7C,IAAIqC,KAAK,EAAE;MACTH,uBAAuB,CAACK,MAAM,CAACvC,IAAI,CAAC;MACpCqC,KAAK,CAACM,OAAO,CAAC,UAAUrE,eAAe,EAAE8D,OAAO,EAAE;QAChD5D,qBAAqB,CAACF,eAAe,CAAC;QACtCoE,UAAU,CAACE,GAAG,CAACR,OAAO,CAAC;MACzB,CAAC,CAAC;IACJ;IACA,OAAOM,UAAU;EACnB,CAAC;EACD,IAAIG,wBAAwB,GAAG,IAAIlD,OAAO,CAAC,CAAC;EAC5C,IAAImD,wBAAwB,GAAG,SAASA,wBAAwBA,CAACV,OAAO,EAAE;IACxE,IAAIW,qBAAqB,GAAGF,wBAAwB,CAAC9D,GAAG,CAACqD,OAAO,CAAC;IACjE,IAAI,CAACW,qBAAqB,EAAE;MAC1BA,qBAAqB,GAAG,IAAI/B,GAAG,CAAC,CAAC;MACjC6B,wBAAwB,CAAC/C,GAAG,CAACsC,OAAO,EAAEW,qBAAqB,CAAC;IAC9D;IACA,OAAOA,qBAAqB;EAC9B,CAAC;EACD,IAAIC,YAAY,GAAG,SAASA,YAAYA,CAACZ,OAAO,EAAEpC,IAAI,EAAE;IACtD,IAAIoC,OAAO,EAAE;MACX,IAAIW,qBAAqB,GAAGD,wBAAwB,CAACV,OAAO,CAAC;MAC7D,IAAIa,UAAU,GAAGF,qBAAqB,CAAChE,GAAG,CAACiB,IAAI,CAAC;MAChD,IAAI,CAACiD,UAAU,EAAE;QACfA,UAAU,GAAGD,YAAY,CAACZ,OAAO,CAACc,CAAC,EAAElD,IAAI,CAAC;QAC1C,IAAIiD,UAAU,IAAI,GAAG,IAAIA,UAAU,IAAI5E,iCAAiC,CAAC4E,UAAU,CAACC,CAAC,CAAC,EAAE;UACtFD,UAAU,GAAGE,SAAS;QACxB;QACA,IAAIF,UAAU,EAAE;UACdF,qBAAqB,CAACjD,GAAG,CAACE,IAAI,EAAEiD,UAAU,CAAC;QAC7C;MACF;MACA,OAAOA,UAAU;IACnB;IACA,OAAOpC,qBAAqB,CAAC9B,GAAG,CAACiB,IAAI,CAAC;EACxC,CAAC;EACD,IAAIoD,YAAY,GAAG,SAASA,YAAYA,CAAChB,OAAO,EAAEpC,IAAI,EAAE0B,SAAS,EAAE;IACjE,IAAIP,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzCzF,MAAM,CAACmG,MAAM,CAACL,SAAS,CAAC;IAC1B;IACA,IAAIU,OAAO,EAAE;MACX,IAAIW,qBAAqB,GAAGD,wBAAwB,CAACV,OAAO,CAAC;MAC7DW,qBAAqB,CAACjD,GAAG,CAACE,IAAI,EAAE0B,SAAS,CAAC;IAC5C,CAAC,MAAM;MACL,IAAI2B,aAAa,GAAGxC,qBAAqB,CAAC9B,GAAG,CAACiB,IAAI,CAAC;MACnDa,qBAAqB,CAACf,GAAG,CAACE,IAAI,EAAE0B,SAAS,CAAC;MAC1C,IAAI,CAACX,UAAU,CAACuC,GAAG,CAACtD,IAAI,CAAC,EAAE;QACzBe,UAAU,CAACjB,GAAG,CAACE,IAAI,EAAEqD,aAAa,CAAC;MACrC;IACF;EACF,CAAC;EACD,IAAIE,sBAAsB,GAAG,SAASA,sBAAsBA,CAACnB,OAAO,EAAEoB,oBAAoB,EAAEC,YAAY,EAAE;IACxG,IAAID,oBAAoB,KAAK,KAAK,CAAC,EAAE;MACnCA,oBAAoB,GAAG,IAAIxC,GAAG,CAAC,CAAC;IAClC;IACA,IAAI,CAACyC,YAAY,EAAE;MACjB,OAAOD,oBAAoB;IAC7B;IACA,IAAIE,gBAAgB,GAAG,IAAI1C,GAAG,CAAC,CAAC;IAChC,IAAI2C,OAAO,GAAG,KAAK;IACnBF,YAAY,CAACd,OAAO,CAAC,UAAU3C,IAAI,EAAE;MACnC,IAAI4D,aAAa;MACjB,IAAIC,QAAQ,GAAG,CAAC,CAACD,aAAa,GAAGZ,YAAY,CAACZ,OAAO,EAAEpC,IAAI,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG4D,aAAa,CAAChC,CAAC,KAAK,CAAC;MACtG8B,gBAAgB,CAAC5D,GAAG,CAACE,IAAI,EAAE6D,QAAQ,CAAC;MACpC,IAAIL,oBAAoB,CAACzE,GAAG,CAACiB,IAAI,CAAC,KAAK6D,QAAQ,EAAE;QAC/CF,OAAO,GAAG,IAAI;MAChB;IACF,CAAC,CAAC;IACF,IAAIH,oBAAoB,CAAChB,IAAI,KAAKkB,gBAAgB,CAAClB,IAAI,IAAI,CAACmB,OAAO,EAAE;MACnE,OAAOH,oBAAoB;IAC7B;IACA,OAAOE,gBAAgB;EACzB,CAAC;EACD,IAAII,YAAY,GAAG,SAASA,YAAYA,CAAC1B,OAAO,EAAEpC,IAAI,EAAEhC,KAAK,EAAEyF,YAAY,EAAEnF,eAAe,EAAE;IAC5F,IAAIoD,SAAS,GAAGsB,YAAY,CAACZ,OAAO,EAAEpC,IAAI,CAAC;IAC3C,IAAI0B,SAAS,EAAE;MACb,IAAIpD,eAAe,KAAK,EAAE,GAAG,IAAIoD,SAAS,CAAC,IAAI,CAAC1C,sBAAsB,CAAC0C,SAAS,CAACwB,CAAC,EAAE5E,eAAe,CAAC,CAAC,EAAE;QACrG,OAAOoD,SAAS;MAClB;MACA,IAAI,GAAG,IAAIA,SAAS,EAAE;QACpBlD,qBAAqB,CAACkD,SAAS,CAACwB,CAAC,CAAC;MACpC;IACF;IACA,IAAIa,aAAa,GAAG;MAClBpC,CAAC,EAAE3D,KAAK;MACR4D,CAAC,EAAE,CAACF,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACE,CAAC,KAAK,CAAC;MAClDC,CAAC,EAAE,IAAI;MACPC,CAAC,EAAEyB,sBAAsB,CAACnB,OAAO,EAAEV,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACI,CAAC,EAAE2B,YAAY;IAC3F,CAAC;IACD,IAAIE,OAAO,GAAG,EAAEjC,SAAS,IAAI,IAAI,IAAIA,SAAS,CAACG,CAAC,CAAC;IACjD,IAAI,CAACH,SAAS,IAAI,EAAE,GAAG,IAAIA,SAAS,CAAC,IAAI,CAAC9F,MAAM,CAACoI,EAAE,CAACtC,SAAS,CAACC,CAAC,EAAE3D,KAAK,CAAC,EAAE;MACvE2F,OAAO,GAAG,IAAI;MACd,EAAEI,aAAa,CAACnC,CAAC;MACjB,IAAImC,aAAa,CAACjC,CAAC,CAACwB,GAAG,CAACtD,IAAI,CAAC,EAAE;QAC7B+D,aAAa,CAACjC,CAAC,GAAG,IAAId,GAAG,CAAC+C,aAAa,CAACjC,CAAC,CAAC,CAAChC,GAAG,CAACE,IAAI,EAAE+D,aAAa,CAACnC,CAAC,CAAC;MACvE;IACF,CAAC,MAAM,IAAImC,aAAa,CAACjC,CAAC,KAAKJ,SAAS,CAACI,CAAC,KAAKiC,aAAa,CAACjC,CAAC,CAACU,IAAI,KAAKd,SAAS,CAACI,CAAC,CAACU,IAAI,IAAI,CAACtF,KAAK,CAACC,IAAI,CAAC4G,aAAa,CAACjC,CAAC,CAACmC,IAAI,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,UAAUC,CAAC,EAAE;MACjJ,OAAOzC,SAAS,CAACI,CAAC,CAACwB,GAAG,CAACa,CAAC,CAAC;IAC3B,CAAC,CAAC,CAAC,EAAE;MACHR,OAAO,GAAG,IAAI;MACdpE,OAAO,CAACC,OAAO,CAAC,CAAC,CAAC8C,IAAI,CAAC,YAAY;QACjC8B,YAAY,CAAChC,OAAO,CAAC;MACvB,CAAC,CAAC;IACJ;IACA,IAAIV,SAAS,IAAI,CAACiC,OAAO,EAAE;MACzB,OAAOjC,SAAS;IAClB;IACA0B,YAAY,CAAChB,OAAO,EAAEpC,IAAI,EAAE+D,aAAa,CAAC;IAC1C,OAAOA,aAAa;EACtB,CAAC;EACD,IAAIM,gBAAgB,GAAG,SAASA,gBAAgBA,CAACjC,OAAO,EAAEpC,IAAI,EAAEsE,KAAK,EAAEb,YAAY,EAAEnF,eAAe,EAAE;IACpG,IAAIoD,SAAS,GAAGsB,YAAY,CAACZ,OAAO,EAAEpC,IAAI,CAAC;IAC3C,IAAI0B,SAAS,EAAE;MACb,IAAIpD,eAAe,KAAK,EAAE,GAAG,IAAIoD,SAAS,CAAC,IAAI,CAAC1C,sBAAsB,CAAC0C,SAAS,CAACwB,CAAC,EAAE5E,eAAe,CAAC,CAAC,EAAE;QACrG,OAAOoD,SAAS;MAClB;MACA,IAAI,GAAG,IAAIA,SAAS,EAAE;QACpBlD,qBAAqB,CAACkD,SAAS,CAACwB,CAAC,CAAC;MACpC;IACF;IACA,IAAIa,aAAa,GAAG;MAClBQ,CAAC,EAAED,KAAK;MACR1C,CAAC,EAAE,CAAC,CAACF,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACE,CAAC,KAAK,CAAC,IAAI,CAAC;MACxDC,CAAC,EAAE,IAAI;MACPC,CAAC,EAAEyB,sBAAsB,CAACnB,OAAO,EAAEV,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACI,CAAC,EAAE2B,YAAY;IAC3F,CAAC;IACDL,YAAY,CAAChB,OAAO,EAAEpC,IAAI,EAAE+D,aAAa,CAAC;IAC1C,OAAOA,aAAa;EACtB,CAAC;EACD,IAAIS,sBAAsB,GAAG,SAASA,sBAAsBA,CAACpC,OAAO,EAAEpC,IAAI,EAAE1B,eAAe,EAAEmF,YAAY,EAAE;IACzG,IAAI/B,SAAS,GAAGsB,YAAY,CAACZ,OAAO,EAAEpC,IAAI,CAAC;IAC3C,IAAI0B,SAAS,IAAI,GAAG,IAAIA,SAAS,EAAE;MACjC,IAAI1C,sBAAsB,CAAC0C,SAAS,CAACwB,CAAC,EAAE5E,eAAe,CAAC,IAAI,CAACD,iCAAiC,CAACqD,SAAS,CAACwB,CAAC,CAAC,EAAE;QAC3G,IAAI,CAACxB,SAAS,CAACG,CAAC,EAAE;UAChB,OAAOlG,QAAQ,CAAC,CAAC,CAAC,EAAE+F,SAAS,EAAE;YAC7BG,CAAC,EAAE;UACL,CAAC,CAAC;QACJ;QACA,OAAOH,SAAS;MAClB;MACAlD,qBAAqB,CAACkD,SAAS,CAACwB,CAAC,CAAC;IACpC;IACAf,yBAAyB,CAACC,OAAO,EAAEpC,IAAI,EAAE1B,eAAe,CAAC;IACzD,IAAIyF,aAAa,GAAG;MAClBb,CAAC,EAAE5E,eAAe;MAClBsD,CAAC,EAAE,CAAC,CAACF,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACE,CAAC,KAAK,CAAC,IAAI,CAAC;MACxDC,CAAC,EAAE,IAAI;MACPC,CAAC,EAAEyB,sBAAsB,CAACnB,OAAO,EAAEV,SAAS,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,SAAS,CAACI,CAAC,EAAE2B,YAAY;IAC3F,CAAC;IACDL,YAAY,CAAChB,OAAO,EAAEpC,IAAI,EAAE+D,aAAa,CAAC;IAC1C,OAAOA,aAAa;EACtB,CAAC;EACD,IAAIU,qBAAqB,GAAG,SAASA,qBAAqBA,CAACrC,OAAO,EAAEpC,IAAI,EAAE0E,cAAc,EAAEjB,YAAY,EAAE;IACtG,IAAIiB,cAAc,YAAYnF,OAAO,EAAE;MACrC,IAAIjB,eAAe,GAAGe,qBAAqB,CAACqF,cAAc,EAAEA,cAAc,CAACpC,IAAI,CAAC,UAAUtE,KAAK,EAAE;QAC/F8F,YAAY,CAAC1B,OAAO,EAAEpC,IAAI,EAAEhC,KAAK,EAAEyF,YAAY,EAAEnF,eAAe,CAAC;MACnE,CAAC,CAAC,CAACqG,KAAK,CAAC,UAAUJ,CAAC,EAAE;QACpB,IAAIA,CAAC,YAAYhF,OAAO,EAAE;UACxB,IAAIpB,iBAAiB,CAACoG,CAAC,CAAC,EAAE;YACxB,OAAOA,CAAC,CAACjC,IAAI,CAAC,YAAY;cACxBsC,aAAa,CAACxC,OAAO,EAAEpC,IAAI,EAAE,IAAI,CAAC;YACpC,CAAC,CAAC;UACJ;UACA,OAAOuE,CAAC;QACV;QACAF,gBAAgB,CAACjC,OAAO,EAAEpC,IAAI,EAAEuE,CAAC,EAAEd,YAAY,EAAEnF,eAAe,CAAC;MACnE,CAAC,CAAC,CAAC;MACH,OAAOkG,sBAAsB,CAACpC,OAAO,EAAEpC,IAAI,EAAE1B,eAAe,EAAEmF,YAAY,CAAC;IAC7E;IACA,OAAOK,YAAY,CAAC1B,OAAO,EAAEpC,IAAI,EAAE0E,cAAc,EAAEjB,YAAY,CAAC;EAClE,CAAC;EACD,IAAIoB,kBAAkB,GAAG,SAASA,kBAAkBA,CAACzC,OAAO,EAAEpC,IAAI,EAAE;IAClE,IAAI0B,SAAS,GAAGsB,YAAY,CAACZ,OAAO,EAAEpC,IAAI,CAAC;IAC3C,IAAI0B,SAAS,EAAE;MACb,IAAIqC,aAAa,GAAGpI,QAAQ,CAAC,CAAC,CAAC,EAAE+F,SAAS,EAAE;QAC1CG,CAAC,EAAE;MACL,CAAC,CAAC;MACFuB,YAAY,CAAChB,OAAO,EAAEpC,IAAI,EAAE+D,aAAa,CAAC;IAC5C,CAAC,MAAM,IAAI5C,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MAChDW,OAAO,CAACC,IAAI,CAAC,8CAA8C,EAAEjC,IAAI,CAAC;IACpE;EACF,CAAC;EACD,IAAI4E,aAAa,GAAG,SAASA,aAAaA,CAACxC,OAAO,EAAEpC,IAAI,EAAE8E,KAAK,EAAE;IAC/D,IAAI,CAACA,KAAK,EAAE;MACV,IAAIC,WAAW,GAAG/B,YAAY,CAACZ,OAAO,EAAEpC,IAAI,CAAC;MAC7C,IAAI+E,WAAW,EAAE;QACf,IAAIA,WAAW,CAAClD,CAAC,IAAI,GAAG,IAAIkD,WAAW,IAAI,CAAC1G,iCAAiC,CAAC0G,WAAW,CAAC7B,CAAC,CAAC,EAAE;UAC5F,OAAO6B,WAAW;QACpB;QACAA,WAAW,CAACjD,CAAC,CAACa,OAAO,CAAC,UAAUqC,CAAC,EAAEb,CAAC,EAAE;UACpC,IAAIA,CAAC,KAAKnE,IAAI,EAAE;YACd,IAAI,CAACc,UAAU,CAACwC,GAAG,CAACa,CAAC,CAAC,EAAE;cACtBS,aAAa,CAACxC,OAAO,EAAE+B,CAAC,CAAC;YAC3B,CAAC,MAAM;cACL,IAAIc,MAAM,GAAGjC,YAAY,CAACZ,OAAO,EAAE+B,CAAC,CAAC;cACrC,IAAIc,MAAM,IAAI,CAACA,MAAM,CAACpD,CAAC,EAAE;gBACvB+C,aAAa,CAACxC,OAAO,EAAE+B,CAAC,CAAC;cAC3B;YACF;UACF;QACF,CAAC,CAAC;QACF,IAAIjH,KAAK,CAACC,IAAI,CAAC4H,WAAW,CAACjD,CAAC,CAAC,CAACoC,KAAK,CAAC,UAAUgB,IAAI,EAAE;UAClD,IAAIf,CAAC,GAAGe,IAAI,CAAC,CAAC,CAAC;YACbtD,CAAC,GAAGsD,IAAI,CAAC,CAAC,CAAC;UACb,IAAID,MAAM,GAAGjC,YAAY,CAACZ,OAAO,EAAE+B,CAAC,CAAC;UACrC,OAAOc,MAAM,IAAI,EAAE,GAAG,IAAIA,MAAM,CAAC,IAAIA,MAAM,CAACrD,CAAC,KAAKA,CAAC;QACrD,CAAC,CAAC,EAAE;UACF,IAAI,CAACmD,WAAW,CAAClD,CAAC,EAAE;YAClB,OAAOlG,QAAQ,CAAC,CAAC,CAAC,EAAEoJ,WAAW,EAAE;cAC/BlD,CAAC,EAAE;YACL,CAAC,CAAC;UACJ;UACA,OAAOkD,WAAW;QACpB;MACF;IACF;IACA,IAAItB,YAAY,GAAG,IAAInC,GAAG,CAAC,CAAC;IAC5B,IAAI;MACF,IAAIoD,cAAc,GAAG1E,IAAI,CAACmF,IAAI,CAAC,UAAUhB,CAAC,EAAE;QAC1CV,YAAY,CAACb,GAAG,CAACuB,CAAC,CAAC;QACnB,IAAIc,MAAM,GAAGd,CAAC,KAAKnE,IAAI,GAAGgD,YAAY,CAACZ,OAAO,EAAE+B,CAAC,CAAC,GAAGS,aAAa,CAACxC,OAAO,EAAE+B,CAAC,CAAC;QAC9E,IAAIc,MAAM,EAAE;UACV,IAAI,GAAG,IAAIA,MAAM,EAAE;YACjB,MAAMA,MAAM,CAACV,CAAC;UAChB;UACA,IAAI,GAAG,IAAIU,MAAM,EAAE;YACjB,MAAMA,MAAM,CAAC/B,CAAC;UAChB;UACA,OAAO+B,MAAM,CAACtD,CAAC;QACjB;QACA,IAAI5B,eAAe,CAACoE,CAAC,CAAC,EAAE;UACtB,OAAOA,CAAC,CAACiB,IAAI;QACf;QACA,MAAM,IAAIC,KAAK,CAAC,cAAc,CAAC;MACjC,CAAC,CAAC;MACF,OAAOZ,qBAAqB,CAACrC,OAAO,EAAEpC,IAAI,EAAE0E,cAAc,EAAEjB,YAAY,CAAC;IAC3E,CAAC,CAAC,OAAO6B,cAAc,EAAE;MACvB,IAAIA,cAAc,YAAY/F,OAAO,EAAE;QACrC,IAAIjB,eAAe,GAAGH,iBAAiB,CAACmH,cAAc,CAAC,IAAIjH,iCAAiC,CAACiH,cAAc,CAAC,GAAG5F,mBAAmB,CAAC4F,cAAc,CAAC,GAAGjG,qBAAqB,CAACiG,cAAc,EAAEA,cAAc,CAAC;QAC1M,OAAOd,sBAAsB,CAACpC,OAAO,EAAEpC,IAAI,EAAE1B,eAAe,EAAEmF,YAAY,CAAC;MAC7E;MACA,OAAOY,gBAAgB,CAACjC,OAAO,EAAEpC,IAAI,EAAEsF,cAAc,EAAE7B,YAAY,CAAC;IACtE;EACF,CAAC;EACD,IAAI8B,QAAQ,GAAG,SAASA,QAAQA,CAACC,WAAW,EAAEpD,OAAO,EAAE;IACrD,IAAIV,SAAS,GAAGkD,aAAa,CAACxC,OAAO,EAAEoD,WAAW,CAAC;IACnD,OAAO9D,SAAS;EAClB,CAAC;EACD,IAAI+D,OAAO,GAAG,SAASA,OAAOA,CAACrD,OAAO,EAAEsD,UAAU,EAAE;IAClD,IAAIC,OAAO,GAAG7E,UAAU,CAAC/B,GAAG,CAAC2G,UAAU,CAAC;IACxC,IAAI,CAACC,OAAO,EAAE;MACZA,OAAO,GAAGC,SAAS,CAACxD,OAAO,EAAEsD,UAAU,CAAC;IAC1C;IACA,OAAOC,OAAO;EAChB,CAAC;EACD,IAAIE,cAAc,GAAG,SAASA,cAAcA,CAAC7F,IAAI,EAAE2F,OAAO,EAAE;IAC1D,OAAO,CAACA,OAAO,CAACG,CAAC,CAACtD,IAAI,KAAK,CAACmD,OAAO,CAACI,CAAC,CAACvD,IAAI,IAAImD,OAAO,CAACI,CAAC,CAACvD,IAAI,KAAK,CAAC,IAAImD,OAAO,CAACI,CAAC,CAACzC,GAAG,CAACtD,IAAI,CAAC,CAAC;EAC5F,CAAC;EACD,IAAIgG,OAAO,GAAG,SAASA,OAAOA,CAAC5D,OAAO,EAAE6D,YAAY,EAAE;IACpD,IAAIN,OAAO,GAAG7E,UAAU,CAAC/B,GAAG,CAACkH,YAAY,CAAC;IAC1C,IAAIN,OAAO,IAAIE,cAAc,CAACI,YAAY,EAAEN,OAAO,CAAC,EAAE;MACpDO,WAAW,CAAC9D,OAAO,EAAE6D,YAAY,CAAC;IACpC;EACF,CAAC;EACD,IAAIE,oBAAoB,GAAG,SAASA,oBAAoBA,CAAC/D,OAAO,EAAEpC,IAAI,EAAE;IACtE,IAAI2F,OAAO,GAAG7E,UAAU,CAAC/B,GAAG,CAACiB,IAAI,CAAC;IAClC2F,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACI,CAAC,CAACpD,OAAO,CAAC,UAAUyD,SAAS,EAAE;MAChE,IAAIA,SAAS,KAAKpG,IAAI,EAAE;QACtB6E,kBAAkB,CAACzC,OAAO,EAAEgE,SAAS,CAAC;QACtCD,oBAAoB,CAAC/D,OAAO,EAAEgE,SAAS,CAAC;MAC1C;IACF,CAAC,CAAC;EACJ,CAAC;EACD,IAAIC,cAAc,GAAG,SAASA,cAAcA,CAACjE,OAAO,EAAEpC,IAAI,EAAEsG,MAAM,EAAE;IAClE,IAAIC,MAAM,GAAG,IAAI;IACjB,IAAIC,WAAW,GAAG,SAASA,WAAWA,CAACrC,CAAC,EAAEsC,OAAO,EAAE;MACjD,IAAIxB,MAAM,GAAGL,aAAa,CAACxC,OAAO,EAAE+B,CAAC,CAAC;MACtC,IAAI,GAAG,IAAIc,MAAM,EAAE;QACjB,MAAMA,MAAM,CAACV,CAAC;MAChB;MACA,IAAI,GAAG,IAAIU,MAAM,EAAE;QACjB,IAAIwB,OAAO,IAAI,IAAI,IAAIA,OAAO,CAACC,gBAAgB,EAAE;UAC/C,OAAOzB,MAAM,CAAC/B,CAAC,CAACZ,IAAI,CAAC,YAAY;YAC/B,IAAIqE,CAAC,GAAG3D,YAAY,CAACZ,OAAO,EAAE+B,CAAC,CAAC;YAChC,IAAIwC,CAAC,IAAI,GAAG,IAAIA,CAAC,IAAIA,CAAC,CAACzD,CAAC,KAAK+B,MAAM,CAAC/B,CAAC,EAAE;cACrC,OAAO,IAAI3D,OAAO,CAAC,UAAUC,OAAO,EAAE;gBACpC,OAAOoH,UAAU,CAACpH,OAAO,CAAC;cAC5B,CAAC,CAAC,CAAC8C,IAAI,CAAC,YAAY;gBAClB,OAAOkE,WAAW,CAACrC,CAAC,EAAEsC,OAAO,CAAC;cAChC,CAAC,CAAC;YACJ;YACA,OAAOD,WAAW,CAACrC,CAAC,EAAEsC,OAAO,CAAC;UAChC,CAAC,CAAC;QACJ;QACA,IAAItF,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;UACzCW,OAAO,CAAC6E,IAAI,CAAC,4EAA4E,EAAE1C,CAAC,CAAC;QAC/F;QACA,MAAMc,MAAM,CAAC/B,CAAC;MAChB;MACA,IAAI,GAAG,IAAI+B,MAAM,EAAE;QACjB,OAAOA,MAAM,CAACtD,CAAC;MACjB;MACA,IAAIR,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;QACzCW,OAAO,CAACC,IAAI,CAAC,qFAAqF,EAAEkC,CAAC,CAAC;MACxG;MACA,MAAM,IAAIkB,KAAK,CAAC,gBAAgB,CAAC;IACnC,CAAC;IACD,IAAIyB,MAAM,GAAG,SAASA,MAAMA,CAAC3C,CAAC,EAAExC,CAAC,EAAE;MACjC,IAAIoF,aAAa;MACjB,IAAI5C,CAAC,KAAKnE,IAAI,EAAE;QACd,IAAI,CAACD,eAAe,CAACoE,CAAC,CAAC,EAAE;UACvB,MAAM,IAAIkB,KAAK,CAAC,mBAAmB,CAAC;QACtC;QACA,IAAI3C,UAAU,GAAGD,+BAA+B,CAAC0B,CAAC,CAAC;QACnDzB,UAAU,CAACC,OAAO,CAAC,UAAUqE,gBAAgB,EAAE;UAC7C,IAAIA,gBAAgB,KAAK5E,OAAO,EAAE;YAChCqC,qBAAqB,CAACuC,gBAAgB,EAAE7C,CAAC,EAAExC,CAAC,CAAC;UAC/C;QACF,CAAC,CAAC;QACF,IAAI0B,aAAa,GAAGL,YAAY,CAACZ,OAAO,EAAE+B,CAAC,CAAC;QAC5C,IAAIJ,aAAa,GAAGU,qBAAqB,CAACrC,OAAO,EAAE+B,CAAC,EAAExC,CAAC,CAAC;QACxD,IAAI0B,aAAa,KAAKU,aAAa,EAAE;UACnCoC,oBAAoB,CAAC/D,OAAO,EAAE+B,CAAC,CAAC;QAClC;MACF,CAAC,MAAM;QACL4C,aAAa,GAAGV,cAAc,CAACjE,OAAO,EAAE+B,CAAC,EAAExC,CAAC,CAAC;MAC/C;MACA,IAAI,CAAC4E,MAAM,EAAE;QACXnC,YAAY,CAAChC,OAAO,CAAC;MACvB;MACA,OAAO2E,aAAa;IACtB,CAAC;IACD,IAAIA,aAAa,GAAG/G,IAAI,CAACiH,KAAK,CAACT,WAAW,EAAEM,MAAM,EAAER,MAAM,CAAC;IAC3DC,MAAM,GAAG,KAAK;IACd,OAAOQ,aAAa;EACtB,CAAC;EACD,IAAIG,SAAS,GAAG,SAASA,SAASA,CAACC,WAAW,EAAEb,MAAM,EAAElE,OAAO,EAAE;IAC/D,IAAI2E,aAAa,GAAGV,cAAc,CAACjE,OAAO,EAAE+E,WAAW,EAAEb,MAAM,CAAC;IAChElC,YAAY,CAAChC,OAAO,CAAC;IACrB,OAAO2E,aAAa;EACtB,CAAC;EACD,IAAIK,sBAAsB,GAAG,SAASA,sBAAsBA,CAACpH,IAAI,EAAE;IACjE,OAAO,CAAC,CAACA,IAAI,CAACiH,KAAK;EACrB,CAAC;EACD,IAAIrB,SAAS,GAAG,SAASA,SAASA,CAACxD,OAAO,EAAEpC,IAAI,EAAEqH,gBAAgB,EAAE;IAClE,IAAI1B,OAAO,GAAG;MACZI,CAAC,EAAE,IAAIzE,GAAG,CAAC+F,gBAAgB,IAAI,CAACA,gBAAgB,CAAC,CAAC;MAClDvB,CAAC,EAAE,IAAIxE,GAAG,CAAC;IACb,CAAC;IACDR,UAAU,CAAChB,GAAG,CAACE,IAAI,EAAE2F,OAAO,CAAC;IAC7B,IAAIxE,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzCH,YAAY,CAAC0B,GAAG,CAAC5C,IAAI,CAAC;IACxB;IACA,IAAI0B,SAAS,GAAGkD,aAAa,CAACzB,SAAS,EAAEnD,IAAI,CAAC;IAC9C0B,SAAS,CAACI,CAAC,CAACa,OAAO,CAAC,UAAUqC,CAAC,EAAEb,CAAC,EAAE;MAClC,IAAImD,QAAQ,GAAGxG,UAAU,CAAC/B,GAAG,CAACoF,CAAC,CAAC;MAChC,IAAImD,QAAQ,EAAE;QACZA,QAAQ,CAACvB,CAAC,CAACnD,GAAG,CAAC5C,IAAI,CAAC;MACtB,CAAC,MAAM;QACL,IAAImE,CAAC,KAAKnE,IAAI,EAAE;UACd4F,SAAS,CAACxD,OAAO,EAAE+B,CAAC,EAAEnE,IAAI,CAAC;QAC7B;MACF;IACF,CAAC,CAAC;IACF,IAAIoH,sBAAsB,CAACpH,IAAI,CAAC,IAAIA,IAAI,CAACuH,OAAO,EAAE;MAChD,IAAIC,OAAO,GAAG,SAASA,OAAOA,CAAClB,MAAM,EAAE;QACrC,OAAOY,SAAS,CAAClH,IAAI,EAAEsG,MAAM,EAAElE,OAAO,CAAC;MACzC,CAAC;MACD,IAAIqF,SAAS,GAAGzH,IAAI,CAACuH,OAAO,CAACC,OAAO,CAAC;MACrCpF,OAAO,GAAGe,SAAS;MACnB,IAAIsE,SAAS,EAAE;QACb9B,OAAO,CAAC+B,CAAC,GAAGD,SAAS;MACvB;IACF;IACA,OAAO9B,OAAO;EAChB,CAAC;EACD,IAAIO,WAAW,GAAG,SAASA,WAAWA,CAAC9D,OAAO,EAAEpC,IAAI,EAAE;IACpD,IAAI2H,eAAe;IACnB,IAAIF,SAAS,GAAG,CAACE,eAAe,GAAG7G,UAAU,CAAC/B,GAAG,CAACiB,IAAI,CAAC,KAAK,IAAI,GAAG,KAAK,CAAC,GAAG2H,eAAe,CAACD,CAAC;IAC7F,IAAID,SAAS,EAAE;MACbA,SAAS,CAAC,CAAC;IACb;IACA3G,UAAU,CAACyB,MAAM,CAACvC,IAAI,CAAC;IACvB,IAAImB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzCH,YAAY,CAACqB,MAAM,CAACvC,IAAI,CAAC;IAC3B;IACA,IAAI0B,SAAS,GAAGsB,YAAY,CAACZ,OAAO,EAAEpC,IAAI,CAAC;IAC3C,IAAI0B,SAAS,EAAE;MACb,IAAI,GAAG,IAAIA,SAAS,EAAE;QACpBlD,qBAAqB,CAACkD,SAAS,CAACwB,CAAC,CAAC;MACpC;MACAxB,SAAS,CAACI,CAAC,CAACa,OAAO,CAAC,UAAUqC,CAAC,EAAEb,CAAC,EAAE;QAClC,IAAIA,CAAC,KAAKnE,IAAI,EAAE;UACd,IAAI2F,OAAO,GAAG7E,UAAU,CAAC/B,GAAG,CAACoF,CAAC,CAAC;UAC/B,IAAIwB,OAAO,EAAE;YACXA,OAAO,CAACI,CAAC,CAACxD,MAAM,CAACvC,IAAI,CAAC;YACtB,IAAI6F,cAAc,CAAC1B,CAAC,EAAEwB,OAAO,CAAC,EAAE;cAC9BO,WAAW,CAAC9D,OAAO,EAAE+B,CAAC,CAAC;YACzB;UACF;QACF;MACF,CAAC,CAAC;IACJ,CAAC,MAAM,IAAIhD,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MAChDW,OAAO,CAACC,IAAI,CAAC,4CAA4C,EAAEjC,IAAI,CAAC;IAClE;EACF,CAAC;EACD,IAAI4H,iBAAiB,GAAG,SAASA,iBAAiBA,CAACxF,OAAO,EAAEpC,IAAI,EAAE0B,SAAS,EAAE8B,oBAAoB,EAAE;IACjG,IAAIC,YAAY,GAAG,IAAInC,GAAG,CAACI,SAAS,CAACI,CAAC,CAACmC,IAAI,CAAC,CAAC,CAAC;IAC9CT,oBAAoB,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,oBAAoB,CAACb,OAAO,CAAC,UAAUqC,CAAC,EAAEb,CAAC,EAAE;MACnF,IAAIV,YAAY,CAACH,GAAG,CAACa,CAAC,CAAC,EAAE;QACvBV,YAAY,CAAClB,MAAM,CAAC4B,CAAC,CAAC;QACtB;MACF;MACA,IAAIwB,OAAO,GAAG7E,UAAU,CAAC/B,GAAG,CAACoF,CAAC,CAAC;MAC/B,IAAIwB,OAAO,EAAE;QACXA,OAAO,CAACI,CAAC,CAACxD,MAAM,CAACvC,IAAI,CAAC;QACtB,IAAI6F,cAAc,CAAC1B,CAAC,EAAEwB,OAAO,CAAC,EAAE;UAC9BO,WAAW,CAAC9D,OAAO,EAAE+B,CAAC,CAAC;QACzB;MACF;IACF,CAAC,CAAC;IACFV,YAAY,CAACd,OAAO,CAAC,UAAUwB,CAAC,EAAE;MAChC,IAAIwB,OAAO,GAAG7E,UAAU,CAAC/B,GAAG,CAACoF,CAAC,CAAC;MAC/B,IAAIwB,OAAO,EAAE;QACXA,OAAO,CAACI,CAAC,CAACnD,GAAG,CAAC5C,IAAI,CAAC;MACrB,CAAC,MAAM,IAAIc,UAAU,CAACwC,GAAG,CAACtD,IAAI,CAAC,EAAE;QAC/B4F,SAAS,CAACxD,OAAO,EAAE+B,CAAC,EAAEnE,IAAI,CAAC;MAC7B;IACF,CAAC,CAAC;EACJ,CAAC;EACD,IAAIoE,YAAY,GAAG,SAASA,YAAYA,CAAChC,OAAO,EAAE;IAChD,IAAIA,OAAO,EAAE;MACX,IAAIW,qBAAqB,GAAGD,wBAAwB,CAACV,OAAO,CAAC;MAC7DW,qBAAqB,CAACJ,OAAO,CAAC,UAAUjB,SAAS,EAAE1B,IAAI,EAAE;QACvD,IAAI6H,kBAAkB,GAAGhH,qBAAqB,CAAC9B,GAAG,CAACiB,IAAI,CAAC;QACxD,IAAI0B,SAAS,KAAKmG,kBAAkB,EAAE;UACpC,IAAIlC,OAAO,GAAG7E,UAAU,CAAC/B,GAAG,CAACiB,IAAI,CAAC;UAClC2F,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACG,CAAC,CAACnD,OAAO,CAAC,UAAUmF,QAAQ,EAAE;YAC/D,OAAOA,QAAQ,CAAC1F,OAAO,CAAC;UAC1B,CAAC,CAAC;QACJ;MACF,CAAC,CAAC;MACF;IACF;IACA,OAAOrB,UAAU,CAACyB,IAAI,EAAE;MACtB,IAAIuF,OAAO,GAAG7K,KAAK,CAACC,IAAI,CAAC4D,UAAU,CAAC;MACpCA,UAAU,CAACiH,KAAK,CAAC,CAAC;MAClBD,OAAO,CAACpF,OAAO,CAAC,UAAUsF,KAAK,EAAE;QAC/B,IAAIjI,IAAI,GAAGiI,KAAK,CAAC,CAAC,CAAC;UACjB5E,aAAa,GAAG4E,KAAK,CAAC,CAAC,CAAC;QAC1B,IAAIvG,SAAS,GAAGsB,YAAY,CAACG,SAAS,EAAEnD,IAAI,CAAC;QAC7C,IAAI0B,SAAS,IAAIA,SAAS,CAACI,CAAC,MAAMuB,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACvB,CAAC,CAAC,EAAE;UACnF8F,iBAAiB,CAACzE,SAAS,EAAEnD,IAAI,EAAE0B,SAAS,EAAE2B,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACvB,CAAC,CAAC;QACjG;QACA,IAAIuB,aAAa,IAAI,CAACA,aAAa,CAACxB,CAAC,IAAIH,SAAS,IAAI,IAAI,IAAIA,SAAS,CAACG,CAAC,EAAE;UACzE;QACF;QACA,IAAI8D,OAAO,GAAG7E,UAAU,CAAC/B,GAAG,CAACiB,IAAI,CAAC;QAClC2F,OAAO,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACG,CAAC,CAACnD,OAAO,CAAC,UAAUmF,QAAQ,EAAE;UAC/D,OAAOA,QAAQ,CAAC,CAAC;QACnB,CAAC,CAAC;MACJ,CAAC,CAAC;IACJ;IACA,IAAI3G,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MACzCJ,cAAc,CAAC0B,OAAO,CAAC,UAAUmD,CAAC,EAAE;QAClC,OAAOA,CAAC,CAAC,CAAC;MACZ,CAAC,CAAC;IACJ;EACF,CAAC;EACD,IAAIoC,2BAA2B,GAAG,SAASA,2BAA2BA,CAAC9F,OAAO,EAAE;IAC9E,IAAIW,qBAAqB,GAAGD,wBAAwB,CAACV,OAAO,CAAC;IAC7DW,qBAAqB,CAACJ,OAAO,CAAC,UAAUjB,SAAS,EAAE1B,IAAI,EAAE;MACvD,IAAIqD,aAAa,GAAGxC,qBAAqB,CAAC9B,GAAG,CAACiB,IAAI,CAAC;MACnD,IAAI,CAACqD,aAAa,IAAI3B,SAAS,CAACE,CAAC,GAAGyB,aAAa,CAACzB,CAAC,IAAIF,SAAS,CAACG,CAAC,KAAKwB,aAAa,CAACxB,CAAC,IAAIH,SAAS,CAACE,CAAC,KAAKyB,aAAa,CAACzB,CAAC,IAAIF,SAAS,CAACI,CAAC,KAAKuB,aAAa,CAACvB,CAAC,EAAE;QAC5JjB,qBAAqB,CAACf,GAAG,CAACE,IAAI,EAAE0B,SAAS,CAAC;QAC1C,IAAIA,SAAS,CAACI,CAAC,MAAMuB,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACvB,CAAC,CAAC,EAAE;UACtE8F,iBAAiB,CAACxF,OAAO,EAAEpC,IAAI,EAAE0B,SAAS,EAAE2B,aAAa,IAAI,IAAI,GAAG,KAAK,CAAC,GAAGA,aAAa,CAACvB,CAAC,CAAC;QAC/F;MACF;IACF,CAAC,CAAC;EACJ,CAAC;EACD,IAAIqG,UAAU,GAAG,SAASA,UAAUA,CAACC,KAAK,EAAEhG,OAAO,EAAE;IACnD,IAAIA,OAAO,EAAE;MACX8F,2BAA2B,CAAC9F,OAAO,CAAC;IACtC;IACAgC,YAAY,CAACjB,SAAS,CAAC;EACzB,CAAC;EACD,IAAIkF,aAAa,GAAG,SAASA,aAAaA,CAACrI,IAAI,EAAEsI,QAAQ,EAAElG,OAAO,EAAE;IAClE,IAAIuD,OAAO,GAAGF,OAAO,CAACrD,OAAO,EAAEpC,IAAI,CAAC;IACpC,IAAIuI,SAAS,GAAG5C,OAAO,CAACG,CAAC;IACzByC,SAAS,CAAC3F,GAAG,CAAC0F,QAAQ,CAAC;IACvB,OAAO,YAAY;MACjBC,SAAS,CAAChG,MAAM,CAAC+F,QAAQ,CAAC;MAC1BtC,OAAO,CAAC5D,OAAO,EAAEpC,IAAI,CAAC;IACxB,CAAC;EACH,CAAC;EACD,IAAIwI,YAAY,GAAG,SAASA,YAAYA,CAACC,MAAM,EAAErG,OAAO,EAAE;IACxD,KAAK,IAAIsG,UAAU,GAAGlL,+BAA+B,CAACiL,MAAM,CAAC,EAAEE,MAAM,EAAE,CAAC,CAACA,MAAM,GAAGD,UAAU,CAAC,CAAC,EAAE3K,IAAI,GAAG;MACrG,IAAI6K,YAAY,GAAGD,MAAM,CAAC3K,KAAK;QAC7B6K,MAAM,GAAGD,YAAY,CAAC,CAAC,CAAC;QACxBE,MAAM,GAAGF,YAAY,CAAC,CAAC,CAAC;MAC1B,IAAI7I,eAAe,CAAC8I,MAAM,CAAC,EAAE;QAC3BpE,qBAAqB,CAACrC,OAAO,EAAEyG,MAAM,EAAEC,MAAM,CAAC;QAC9C3C,oBAAoB,CAAC/D,OAAO,EAAEyG,MAAM,CAAC;MACvC;IACF;IACAzE,YAAY,CAAChC,OAAO,CAAC;EACvB,CAAC;EACD,IAAIjB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzC,IAAI0H,KAAK;IACT,OAAOA,KAAK,GAAG,CAAC,CAAC,EAAEA,KAAK,CAAC9I,SAAS,CAAC,GAAGsF,QAAQ,EAAEwD,KAAK,CAAC7I,UAAU,CAAC,GAAGgH,SAAS,EAAE6B,KAAK,CAAC5I,WAAW,CAAC,GAAGgI,UAAU,EAAEY,KAAK,CAAC3I,cAAc,CAAC,GAAGiI,aAAa,EAAEU,KAAK,CAAC1I,aAAa,CAAC,GAAGmI,YAAY,EAAEO,KAAK,CAACzI,mBAAmB,CAAC,GAAG,UAAUwF,CAAC,EAAE;MACpO7E,cAAc,CAAC2B,GAAG,CAACkD,CAAC,CAAC;MACrB,OAAO,YAAY;QACjB7E,cAAc,CAACsB,MAAM,CAACuD,CAAC,CAAC;MAC1B,CAAC;IACH,CAAC,EAAEiD,KAAK,CAACxI,qBAAqB,CAAC,GAAG,YAAY;MAC5C,OAAOW,YAAY,CAACuH,MAAM,CAAC,CAAC;IAC9B,CAAC,EAAEM,KAAK,CAACvI,kBAAkB,CAAC,GAAG,UAAU2D,CAAC,EAAE;MAC1C,OAAOtD,qBAAqB,CAAC9B,GAAG,CAACoF,CAAC,CAAC;IACrC,CAAC,EAAE4E,KAAK,CAACtI,eAAe,CAAC,GAAG,UAAU0D,CAAC,EAAE;MACvC,OAAOrD,UAAU,CAAC/B,GAAG,CAACoF,CAAC,CAAC;IAC1B,CAAC,EAAE4E,KAAK;EACV;EACA,OAAOnI,KAAK,GAAG,CAAC,CAAC,EAAEA,KAAK,CAACX,SAAS,CAAC,GAAGsF,QAAQ,EAAE3E,KAAK,CAACV,UAAU,CAAC,GAAGgH,SAAS,EAAEtG,KAAK,CAACT,WAAW,CAAC,GAAGgI,UAAU,EAAEvH,KAAK,CAACR,cAAc,CAAC,GAAGiI,aAAa,EAAEzH,KAAK,CAACP,aAAa,CAAC,GAAGmI,YAAY,EAAE5H,KAAK;AACnM,CAAC;AACD,IAAIoI,oBAAoB,GAAG,SAASA,oBAAoBA,CAACrI,aAAa,EAAE;EACtE,IAAIsI,KAAK,GAAGvI,WAAW,CAACC,aAAa,CAAC;EACtC,IAAI5B,GAAG,GAAG,SAASA,GAAGA,CAACiB,IAAI,EAAE;IAC3B,IAAI0B,SAAS,GAAGuH,KAAK,CAAChJ,SAAS,CAAC,CAACD,IAAI,CAAC;IACtC,IAAI,GAAG,IAAI0B,SAAS,EAAE;MACpB,MAAMA,SAAS,CAAC6C,CAAC;IACnB;IACA,IAAI,GAAG,IAAI7C,SAAS,EAAE;MACpB,OAAOyB,SAAS;IAClB;IACA,OAAOzB,SAAS,CAACC,CAAC;EACpB,CAAC;EACD,IAAIuH,QAAQ,GAAG,SAASA,QAAQA,CAAClJ,IAAI,EAAE;IACrC,OAAO,IAAIT,OAAO,CAAC,UAAUC,OAAO,EAAE2J,MAAM,EAAE;MAC5C,IAAIzH,SAAS,GAAGuH,KAAK,CAAChJ,SAAS,CAAC,CAACD,IAAI,CAAC;MACtC,IAAI,GAAG,IAAI0B,SAAS,EAAE;QACpByH,MAAM,CAACzH,SAAS,CAAC6C,CAAC,CAAC;MACrB,CAAC,MAAM,IAAI,GAAG,IAAI7C,SAAS,EAAE;QAC3BlC,OAAO,CAACkC,SAAS,CAACwB,CAAC,CAACZ,IAAI,CAAC,YAAY;UACnC,OAAO4G,QAAQ,CAAClJ,IAAI,CAAC;QACvB,CAAC,CAAC,CAAC;MACL,CAAC,MAAM;QACLR,OAAO,CAACkC,SAAS,CAACC,CAAC,CAAC;MACtB;IACF,CAAC,CAAC;EACJ,CAAC;EACD,IAAI7B,GAAG,GAAG,SAASA,GAAGA,CAACE,IAAI,EAAEsG,MAAM,EAAE;IACnC,OAAO2C,KAAK,CAAC/I,UAAU,CAAC,CAACF,IAAI,EAAEsG,MAAM,CAAC;EACxC,CAAC;EACD,IAAI8C,GAAG,GAAG,SAASA,GAAGA,CAACpJ,IAAI,EAAEsI,QAAQ,EAAE;IACrC,OAAOW,KAAK,CAAC7I,cAAc,CAAC,CAACJ,IAAI,EAAEsI,QAAQ,CAAC;EAC9C,CAAC;EACD,OAAO;IACLvJ,GAAG,EAAEA,GAAG;IACRmK,QAAQ,EAAEA,QAAQ;IAClBpJ,GAAG,EAAEA,GAAG;IACRsJ,GAAG,EAAEA,GAAG;IACRC,qBAAqB,EAAEJ;EACzB,CAAC;AACH,CAAC;AAED,IAAIK,oBAAoB,GAAG,SAASA,oBAAoBA,CAAC3I,aAAa,EAAE4I,oBAAoB,EAAE;EAC5F,IAAIN,KAAK,GAAGM,oBAAoB,GAAGA,oBAAoB,CAAC5I,aAAa,CAAC,CAAC0I,qBAAqB,GAAG3I,WAAW,CAACC,aAAa,CAAC;EACzH,OAAO;IACLgG,CAAC,EAAEsC;EACL,CAAC;AACH,CAAC;AACD,IAAIO,eAAe,GAAG,IAAIxI,GAAG,CAAC,CAAC;AAC/B,IAAIyI,eAAe,GAAG,SAASA,eAAeA,CAACC,KAAK,EAAE;EACpD,IAAI,CAACF,eAAe,CAAClG,GAAG,CAACoG,KAAK,CAAC,EAAE;IAC/BF,eAAe,CAAC1J,GAAG,CAAC4J,KAAK,EAAElO,KAAK,CAACmO,aAAa,CAACL,oBAAoB,CAAC,CAAC,CAAC,CAAC;EACzE;EACA,OAAOE,eAAe,CAACzK,GAAG,CAAC2K,KAAK,CAAC;AACnC,CAAC;AAED,IAAIE,QAAQ,GAAG,SAASA,QAAQA,CAAC1E,IAAI,EAAE;EACrC,IAAI2E,QAAQ,GAAG3E,IAAI,CAAC2E,QAAQ;IAC1BlJ,aAAa,GAAGuE,IAAI,CAACvE,aAAa;IAClC+I,KAAK,GAAGxE,IAAI,CAACwE,KAAK;IAClBH,oBAAoB,GAAGrE,IAAI,CAACqE,oBAAoB;IAChDO,6BAA6B,GAAG5E,IAAI,CAAC4E,6BAA6B;EACpE,IAAIC,SAAS,GAAGvO,KAAK,CAACwO,QAAQ,CAAC,CAAC,CAAC,CAAC;IAChC5H,OAAO,GAAG2H,SAAS,CAAC,CAAC,CAAC;IACtBE,UAAU,GAAGF,SAAS,CAAC,CAAC,CAAC;EAC3BvO,KAAK,CAAC0O,SAAS,CAAC,YAAY;IAC1B,IAAIC,cAAc,GAAGC,iBAAiB,CAACC,OAAO;IAC9C,IAAIF,cAAc,CAACG,CAAC,EAAE;MACpBH,cAAc,CAACxD,CAAC,CAACxG,WAAW,CAAC,CAAC,IAAI,EAAEiC,OAAO,CAAC;MAC5C,OAAOA,OAAO,CAACc,CAAC;MAChBiH,cAAc,CAACxI,CAAC,GAAGS,OAAO;IAC5B;EACF,CAAC,EAAE,CAACA,OAAO,CAAC,CAAC;EACb,IAAIgI,iBAAiB,GAAG5O,KAAK,CAAC+O,MAAM,CAAC,CAAC;EACtC,IAAI,CAACH,iBAAiB,CAACC,OAAO,EAAE;IAC9B,IAAIF,cAAc,GAAGb,oBAAoB,CAAC3I,aAAa,EAAE4I,oBAAoB,CAAC;IAC9E,IAAIO,6BAA6B,EAAE;MACjC,IAAIU,QAAQ,GAAG,CAAC;MAChBL,cAAc,CAACG,CAAC,GAAG,UAAUrD,KAAK,EAAE;QAClCgD,UAAU,CAAC,UAAUQ,aAAa,EAAE;UAClC,IAAIC,WAAW,GAAGF,QAAQ,GAAGC,aAAa,GAAG;YAC3CvH,CAAC,EAAEuH;UACL,CAAC;UACDxD,KAAK,CAACyD,WAAW,CAAC;UAClB,OAAOA,WAAW;QACpB,CAAC,CAAC;MACJ,CAAC;MACDP,cAAc,CAACxI,CAAC,GAAGS,OAAO;MAC1B+H,cAAc,CAACvI,CAAC,GAAG,UAAU+I,EAAE,EAAE;QAC/B,EAAEH,QAAQ;QACVG,EAAE,CAAC,CAAC;QACJ,EAAEH,QAAQ;MACZ,CAAC;IACH;IACAJ,iBAAiB,CAACC,OAAO,GAAGF,cAAc;EAC5C;EACA,IAAIS,qBAAqB,GAAGnB,eAAe,CAACC,KAAK,CAAC;EAClD,OAAOlO,KAAK,CAACqP,aAAa,CAACD,qBAAqB,CAAChB,QAAQ,EAAE;IACzD5L,KAAK,EAAEoM,iBAAiB,CAACC;EAC3B,CAAC,EAAER,QAAQ,CAAC;AACd,CAAC;AAED,SAAS7J,IAAIA,CAACmF,IAAI,EAAE8B,KAAK,EAAE;EACzB,OAAOvL,OAAO,CAACsE,IAAI,CAACmF,IAAI,EAAE8B,KAAK,CAAC;AAClC;AAEA,SAAS6D,YAAYA,CAAC9K,IAAI,EAAE0J,KAAK,EAAE;EACjC,IAAIqB,YAAY,GAAGtB,eAAe,CAACC,KAAK,CAAC;EACzC,IAAIS,cAAc,GAAG3O,KAAK,CAACwP,UAAU,CAACD,YAAY,CAAC;EACnD,IAAI9B,KAAK,GAAGkB,cAAc,CAACxD,CAAC;IAC1BsE,mBAAmB,GAAGd,cAAc,CAACxI,CAAC;EACxC,IAAIuJ,YAAY,GAAG,SAASA,YAAYA,CAAC9I,OAAO,EAAE;IAChD,IAAIV,SAAS,GAAGuH,KAAK,CAAChJ,SAAS,CAAC,CAACD,IAAI,EAAEoC,OAAO,CAAC;IAC/C,IAAIjB,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IAAI,CAACK,SAAS,CAACG,CAAC,EAAE;MACzD,MAAM,IAAIwD,KAAK,CAAC,2BAA2B,CAAC;IAC9C;IACA,IAAI,GAAG,IAAI3D,SAAS,EAAE;MACpB,MAAMA,SAAS,CAAC6C,CAAC;IACnB;IACA,IAAI,GAAG,IAAI7C,SAAS,EAAE;MACpB,MAAMA,SAAS,CAACwB,CAAC;IACnB;IACA,IAAI,GAAG,IAAIxB,SAAS,EAAE;MACpB,OAAOA,SAAS,CAACC,CAAC;IACpB;IACA,MAAM,IAAI0D,KAAK,CAAC,eAAe,CAAC;EAClC,CAAC;EACD,IAAI8F,WAAW,GAAG3P,KAAK,CAAC4P,UAAU,CAAC,UAAUC,IAAI,EAAEX,WAAW,EAAE;MAC5D,IAAIY,SAAS,GAAGJ,YAAY,CAACR,WAAW,CAAC;MACzC,IAAI9O,MAAM,CAACoI,EAAE,CAACqH,IAAI,CAAC,CAAC,CAAC,EAAEC,SAAS,CAAC,IAAID,IAAI,CAAC,CAAC,CAAC,KAAKrL,IAAI,EAAE;QACrD,OAAOqL,IAAI;MACb;MACA,OAAO,CAACX,WAAW,EAAEY,SAAS,EAAEtL,IAAI,CAAC;IACvC,CAAC,EAAEiL,mBAAmB,EAAE,UAAUM,cAAc,EAAE;MAChD,IAAIC,YAAY,GAAGN,YAAY,CAACK,cAAc,CAAC;MAC/C,OAAO,CAACA,cAAc,EAAEC,YAAY,EAAExL,IAAI,CAAC;IAC7C,CAAC,CAAC;IACFyL,YAAY,GAAGN,WAAW,CAAC,CAAC,CAAC;IAC7B/I,OAAO,GAAGqJ,YAAY,CAAC,CAAC,CAAC;IACzBC,gBAAgB,GAAGD,YAAY,CAAC,CAAC,CAAC;IAClCE,eAAe,GAAGF,YAAY,CAAC,CAAC,CAAC;IACjCG,iBAAiB,GAAGT,WAAW,CAAC,CAAC,CAAC;EACpC,IAAInN,KAAK,GAAG0N,gBAAgB;EAC5B,IAAIC,eAAe,KAAK3L,IAAI,EAAE;IAC5B4L,iBAAiB,CAACxJ,OAAO,CAAC;IAC1BpE,KAAK,GAAGkN,YAAY,CAAC9I,OAAO,CAAC;EAC/B;EACA5G,KAAK,CAAC0O,SAAS,CAAC,YAAY;IAC1B,IAAIe,mBAAmB,GAAGd,cAAc,CAACxI,CAAC;IAC1C,IAAIsJ,mBAAmB,EAAE;MACvBhC,KAAK,CAAC9I,WAAW,CAAC,CAACH,IAAI,EAAEiL,mBAAmB,CAAC;IAC/C;IACA,IAAIY,WAAW,GAAG5C,KAAK,CAAC7I,cAAc,CAAC,CAACJ,IAAI,EAAE4L,iBAAiB,EAAEX,mBAAmB,CAAC;IACrFW,iBAAiB,CAACX,mBAAmB,CAAC;IACtC,OAAOY,WAAW;EACpB,CAAC,EAAE,CAAC5C,KAAK,EAAEjJ,IAAI,EAAEmK,cAAc,CAAC,CAAC;EACjC3O,KAAK,CAAC0O,SAAS,CAAC,YAAY;IAC1BjB,KAAK,CAAC9I,WAAW,CAAC,CAACH,IAAI,EAAEoC,OAAO,CAAC;EACnC,CAAC,CAAC;EACF5G,KAAK,CAACsQ,aAAa,CAAC9N,KAAK,CAAC;EAC1B,OAAOA,KAAK;AACd;AAEA,SAAS+N,UAAUA,CAAC/L,IAAI,EAAE0J,KAAK,EAAE;EAC/B,IAAIqB,YAAY,GAAGtB,eAAe,CAACC,KAAK,CAAC;EACzC,IAAIsC,WAAW,GAAGxQ,KAAK,CAACwP,UAAU,CAACD,YAAY,CAAC;IAC9C9B,KAAK,GAAG+C,WAAW,CAACrF,CAAC;IACrBsF,cAAc,GAAGD,WAAW,CAAC1B,CAAC;EAChC,IAAI9C,OAAO,GAAGhM,KAAK,CAAC0Q,WAAW,CAAC,UAAU5F,MAAM,EAAE;IAChD,IAAInF,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,IAAI,EAAE,OAAO,IAAIrB,IAAI,CAAC,EAAE;MAC/D,MAAM,IAAIqF,KAAK,CAAC,mBAAmB,CAAC;IACtC;IACA,IAAI4B,KAAK,GAAG,SAASA,KAAKA,CAAC7E,OAAO,EAAE;MAClC,OAAO6G,KAAK,CAAC/I,UAAU,CAAC,CAACF,IAAI,EAAEsG,MAAM,EAAElE,OAAO,CAAC;IACjD,CAAC;IACD,OAAO6J,cAAc,GAAGA,cAAc,CAAChF,KAAK,CAAC,GAAGA,KAAK,CAAC,CAAC;EACzD,CAAC,EAAE,CAACgC,KAAK,EAAEgD,cAAc,EAAEjM,IAAI,CAAC,CAAC;EACjC,OAAOwH,OAAO;AAChB;AAEA,SAAS2E,OAAOA,CAACnM,IAAI,EAAE0J,KAAK,EAAE;EAC5B,IAAI,OAAO,IAAI1J,IAAI,EAAE;IACnBgC,OAAO,CAACC,IAAI,CAAC,mEAAmE,CAAC;IACjFyH,KAAK,GAAG1J,IAAI,CAAC0J,KAAK;EACpB;EACA,OAAO,CAACoB,YAAY,CAAC9K,IAAI,EAAE0J,KAAK,CAAC,EAAEqC,UAAU,CAAC/L,IAAI,EAAE0J,KAAK,CAAC,CAAC;AAC7D;AAEA0C,OAAO,CAACxC,QAAQ,GAAGA,QAAQ;AAC3BwC,OAAO,CAACC,+BAA+B,GAAG5C,eAAe;AACzD2C,OAAO,CAACE,oCAAoC,GAAG1M,oBAAoB;AACnEwM,OAAO,CAACpM,IAAI,GAAGA,IAAI;AACnBoM,OAAO,CAAC7C,oBAAoB,GAAGP,oBAAoB;AACnDoD,OAAO,CAACD,OAAO,GAAGA,OAAO;AACzBC,OAAO,CAACtB,YAAY,GAAGA,YAAY;AACnCsB,OAAO,CAACL,UAAU,GAAGA,UAAU","ignoreList":[]},"metadata":{},"sourceType":"script"}