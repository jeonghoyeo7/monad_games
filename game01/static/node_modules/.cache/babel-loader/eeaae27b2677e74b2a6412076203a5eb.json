{"ast":null,"code":"'use strict';\n\nvar keyCount = 0;\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = function (get) {\n      return get(config);\n    };\n    config.write = function (get, set, arg) {\n      return set(config, typeof arg === 'function' ? arg(get(config)) : arg);\n    };\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\nvar isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n  return !!atom.write;\n};\nvar cancelPromiseMap = new WeakMap();\nvar registerCancelPromise = function registerCancelPromise(promise, cancel) {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(function () {}).finally(function () {\n    return cancelPromiseMap.delete(promise);\n  });\n};\nvar cancelPromise = function cancelPromise(promise, next) {\n  var cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nvar resolvePromise = function resolvePromise(promise, value) {\n  promise.status = 'fulfilled';\n  promise.value = value;\n};\nvar rejectPromise = function rejectPromise(promise, e) {\n  promise.status = 'rejected';\n  promise.reason = e;\n};\nvar isEqualAtomValue = function isEqualAtomValue(a, b) {\n  return 'v' in a && 'v' in b && Object.is(a.v, b.v);\n};\nvar isEqualAtomError = function isEqualAtomError(a, b) {\n  return 'e' in a && 'e' in b && Object.is(a.e, b.e);\n};\nvar hasPromiseAtomValue = function hasPromiseAtomValue(a) {\n  return 'v' in a && a.v instanceof Promise;\n};\nvar returnAtomValue = function returnAtomValue(atomState) {\n  if ('e' in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nvar createStore = function createStore() {\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n  if (process.env.NODE_ENV !== \"production\") {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n  var setAtomState = function setAtomState(atom, atomState) {\n    if (process.env.NODE_ENV !== \"production\") {\n      Object.freeze(atomState);\n    }\n    var prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      var _next = 'v' in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, _next);\n    }\n  };\n  var updateDependencies = function updateDependencies(atom, nextAtomState, depSet) {\n    var dependencies = new Map();\n    var changed = false;\n    depSet.forEach(function (a) {\n      var aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if (process.env.NODE_ENV !== \"production\") {\n        console.warn('[Bug] atom state not found');\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  var setAtomValue = function setAtomValue(atom, value, depSet) {\n    var prevAtomState = getAtomState(atom);\n    var nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomError = function setAtomError(atom, error, depSet) {\n    var prevAtomState = getAtomState(atom);\n    var nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  var readAtomState = function readAtomState(atom) {\n    var atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(function (_ref) {\n        var a = _ref[0],\n          s = _ref[1];\n        return a === atom || getAtomState(a) === s;\n      })) {\n        return atomState;\n      }\n    }\n    var depSet = new Set();\n    var isSync = true;\n    var getter = function getter(a) {\n      depSet.add(a);\n      if (a === atom) {\n        var _aState = getAtomState(a);\n        if (_aState) {\n          return returnAtomValue(_aState);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error('no atom init');\n      }\n      var aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    var controller;\n    var setSelf;\n    var options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if (process.env.NODE_ENV !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn('setSelf function cannot be used with read-only atom');\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = function setSelf() {\n            if (process.env.NODE_ENV !== \"production\" && isSync) {\n              console.warn('setSelf function cannot be called in sync');\n            }\n            if (!isSync) {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return writeAtom.apply(void 0, [atom].concat(args));\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      var value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        var continuePromise;\n        var promise = new Promise(function (resolve, reject) {\n          var settled = false;\n          value.then(function (v) {\n            if (!settled) {\n              resolvePromise(promise, v);\n              resolve(v);\n            }\n          }, function (e) {\n            if (!settled) {\n              rejectPromise(promise, e);\n              reject(e);\n            }\n          }).finally(function () {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n            }\n          });\n          continuePromise = function continuePromise(next) {\n            if (!settled) {\n              settled = true;\n              next.then(function (v) {\n                return resolvePromise(promise, v);\n              }, function (e) {\n                return rejectPromise(promise, e);\n              });\n              resolve(next);\n            }\n          };\n        });\n        promise.status = 'pending';\n        registerCancelPromise(promise, function (next) {\n          var _controller;\n          if (next) {\n            continuePromise(next);\n          }\n          (_controller = controller) == null ? void 0 : _controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  var readAtom = function readAtom(atom) {\n    return returnAtomValue(readAtomState(atom));\n  };\n  var addAtom = function addAtom(atom) {\n    var mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n  var delAtom = function delAtom(atom) {\n    var mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  var recomputeDependents = function recomputeDependents(atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(function (dependent) {\n      if (dependent !== atom) {\n        var prevAtomState = getAtomState(dependent);\n        var nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  var writeAtomState = function writeAtomState(atom) {\n    var isSync = true;\n    var getter = function getter(a) {\n      return returnAtomValue(readAtomState(a));\n    };\n    var setter = function setter(a) {\n      var r;\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('atom not writable');\n        }\n        var prevAtomState = getAtomState(a);\n        var nextAtomState = setAtomValue(a, args[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState.apply(void 0, [a].concat(args));\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    var result = atom.write.apply(atom, [getter, setter].concat(args));\n    isSync = false;\n    return result;\n  };\n  var writeAtom = function writeAtom(atom) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    var result = writeAtomState.apply(void 0, [atom].concat(args));\n    flushPending();\n    return result;\n  };\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (process.env.NODE_ENV !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var onUnmount = atom.onMount(function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        return writeAtom.apply(void 0, [atom].concat(args));\n      });\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (process.env.NODE_ENV !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    var atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n  var mountDependencies = function mountDependencies(atom, atomState, prevDependencies) {\n    var depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach(function (_, a) {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  var flushPending = function flushPending() {\n    while (pendingMap.size) {\n      var pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(function (_ref2) {\n        var atom = _ref2[0],\n          prevAtomState = _ref2[1];\n        var atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          var mounted = mountedMap.get(atom);\n          if (mounted && !(prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach(function (listener) {\n              return listener();\n            });\n          }\n        } else if (process.env.NODE_ENV !== \"production\") {\n          console.warn('[Bug] no atom state to flush');\n        }\n      });\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      stateListeners.forEach(function (l) {\n        return l();\n      });\n    }\n  };\n  var subscribeAtom = function subscribeAtom(atom, listener) {\n    var mounted = addAtom(atom);\n    flushPending();\n    var listeners = mounted.l;\n    listeners.add(listener);\n    return function () {\n      listeners.delete(listener);\n      delAtom(atom);\n    };\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      dev_subscribe_state: function dev_subscribe_state(l) {\n        stateListeners.add(l);\n        return function () {\n          stateListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: function dev_get_mounted_atoms() {\n        return mountedAtoms.values();\n      },\n      dev_get_atom_state: function dev_get_atom_state(a) {\n        return atomStateMap.get(a);\n      },\n      dev_get_mounted: function dev_get_mounted(a) {\n        return mountedMap.get(a);\n      },\n      dev_restore_atoms: function dev_restore_atoms(values) {\n        for (var _iterator = _createForOfIteratorHelperLoose(values), _step; !(_step = _iterator()).done;) {\n          var _step$value = _step.value,\n            atom = _step$value[0],\n            value = _step$value[1];\n          if (hasInitialValue(atom)) {\n            setAtomValue(atom, value);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nvar defaultStore;\nvar getDefaultStore = function getDefaultStore() {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\nexports.atom = atom;\nexports.createStore = createStore;\nexports.getDefaultStore = getDefaultStore;","map":{"version":3,"names":["keyCount","atom","read","write","key","config","toString","init","get","set","arg","_unsupportedIterableToArray","o","minLen","_arrayLikeToArray","n","Object","prototype","call","slice","constructor","name","Array","from","test","arr","len","length","i","arr2","_createForOfIteratorHelperLoose","allowArrayLike","it","Symbol","iterator","next","bind","isArray","done","value","TypeError","hasInitialValue","isActuallyWritableAtom","cancelPromiseMap","WeakMap","registerCancelPromise","promise","cancel","catch","finally","delete","cancelPromise","resolvePromise","status","rejectPromise","e","reason","isEqualAtomValue","a","b","is","v","isEqualAtomError","hasPromiseAtomValue","Promise","returnAtomValue","atomState","createStore","atomStateMap","mountedMap","pendingMap","Map","stateListeners","mountedAtoms","process","env","NODE_ENV","Set","getAtomState","setAtomState","freeze","prevAtomState","has","_next","resolve","reject","updateDependencies","nextAtomState","depSet","dependencies","changed","forEach","aState","d","console","warn","size","setAtomValue","setAtomError","error","readAtomState","_","every","_ref","s","isSync","getter","add","_aState","Error","controller","setSelf","options","signal","AbortController","_len","arguments","args","_key","writeAtom","apply","concat","continuePromise","settled","then","_controller","abort","readAtom","addAtom","mounted","mountAtom","canUnmountAtom","l","t","delAtom","unmountAtom","recomputeDependents","dependent","writeAtomState","setter","r","_len3","_key3","flushPending","_len2","_key2","result","_len4","_key4","initialDependent","aMounted","onMount","onUnmount","_len5","_key5","u","_mountedMap$get","mountDependencies","prevDependencies","keys","pending","clear","_ref2","listener","subscribeAtom","listeners","sub","dev_subscribe_state","dev_get_mounted_atoms","values","dev_get_atom_state","dev_get_mounted","dev_restore_atoms","_iterator","_step","_step$value","defaultStore","getDefaultStore","exports"],"sources":["/Users/jeonghoyeo/toy/monad_games/game01/static/node_modules/jotai/vanilla.js"],"sourcesContent":["'use strict';\n\nvar keyCount = 0;\nfunction atom(read, write) {\n  var key = \"atom\" + ++keyCount;\n  var config = {\n    toString: function toString() {\n      return key;\n    }\n  };\n  if (typeof read === 'function') {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = function (get) {\n      return get(config);\n    };\n    config.write = function (get, set, arg) {\n      return set(config, typeof arg === 'function' ? arg(get(config)) : arg);\n    };\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _createForOfIteratorHelperLoose(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n  if (it) return (it = it.call(o)).next.bind(it);\n  if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n    if (it) o = it;\n    var i = 0;\n    return function () {\n      if (i >= o.length) return {\n        done: true\n      };\n      return {\n        done: false,\n        value: o[i++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nvar hasInitialValue = function hasInitialValue(atom) {\n  return 'init' in atom;\n};\nvar isActuallyWritableAtom = function isActuallyWritableAtom(atom) {\n  return !!atom.write;\n};\nvar cancelPromiseMap = new WeakMap();\nvar registerCancelPromise = function registerCancelPromise(promise, cancel) {\n  cancelPromiseMap.set(promise, cancel);\n  promise.catch(function () {}).finally(function () {\n    return cancelPromiseMap.delete(promise);\n  });\n};\nvar cancelPromise = function cancelPromise(promise, next) {\n  var cancel = cancelPromiseMap.get(promise);\n  if (cancel) {\n    cancelPromiseMap.delete(promise);\n    cancel(next);\n  }\n};\nvar resolvePromise = function resolvePromise(promise, value) {\n  promise.status = 'fulfilled';\n  promise.value = value;\n};\nvar rejectPromise = function rejectPromise(promise, e) {\n  promise.status = 'rejected';\n  promise.reason = e;\n};\nvar isEqualAtomValue = function isEqualAtomValue(a, b) {\n  return 'v' in a && 'v' in b && Object.is(a.v, b.v);\n};\nvar isEqualAtomError = function isEqualAtomError(a, b) {\n  return 'e' in a && 'e' in b && Object.is(a.e, b.e);\n};\nvar hasPromiseAtomValue = function hasPromiseAtomValue(a) {\n  return 'v' in a && a.v instanceof Promise;\n};\nvar returnAtomValue = function returnAtomValue(atomState) {\n  if ('e' in atomState) {\n    throw atomState.e;\n  }\n  return atomState.v;\n};\nvar createStore = function createStore() {\n  var atomStateMap = new WeakMap();\n  var mountedMap = new WeakMap();\n  var pendingMap = new Map();\n  var stateListeners;\n  var mountedAtoms;\n  if (process.env.NODE_ENV !== \"production\") {\n    stateListeners = new Set();\n    mountedAtoms = new Set();\n  }\n  var getAtomState = function getAtomState(atom) {\n    return atomStateMap.get(atom);\n  };\n  var setAtomState = function setAtomState(atom, atomState) {\n    if (process.env.NODE_ENV !== \"production\") {\n      Object.freeze(atomState);\n    }\n    var prevAtomState = atomStateMap.get(atom);\n    atomStateMap.set(atom, atomState);\n    if (!pendingMap.has(atom)) {\n      pendingMap.set(atom, prevAtomState);\n    }\n    if (prevAtomState && hasPromiseAtomValue(prevAtomState)) {\n      var _next = 'v' in atomState ? atomState.v instanceof Promise ? atomState.v : Promise.resolve(atomState.v) : Promise.reject(atomState.e);\n      cancelPromise(prevAtomState.v, _next);\n    }\n  };\n  var updateDependencies = function updateDependencies(atom, nextAtomState, depSet) {\n    var dependencies = new Map();\n    var changed = false;\n    depSet.forEach(function (a) {\n      var aState = a === atom ? nextAtomState : getAtomState(a);\n      if (aState) {\n        dependencies.set(a, aState);\n        if (nextAtomState.d.get(a) !== aState) {\n          changed = true;\n        }\n      } else if (process.env.NODE_ENV !== \"production\") {\n        console.warn('[Bug] atom state not found');\n      }\n    });\n    if (changed || nextAtomState.d.size !== dependencies.size) {\n      nextAtomState.d = dependencies;\n    }\n  };\n  var setAtomValue = function setAtomValue(atom, value, depSet) {\n    var prevAtomState = getAtomState(atom);\n    var nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || new Map(),\n      v: value\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomValue(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  var setAtomError = function setAtomError(atom, error, depSet) {\n    var prevAtomState = getAtomState(atom);\n    var nextAtomState = {\n      d: (prevAtomState == null ? void 0 : prevAtomState.d) || new Map(),\n      e: error\n    };\n    if (depSet) {\n      updateDependencies(atom, nextAtomState, depSet);\n    }\n    if (prevAtomState && isEqualAtomError(prevAtomState, nextAtomState) && prevAtomState.d === nextAtomState.d) {\n      return prevAtomState;\n    }\n    setAtomState(atom, nextAtomState);\n    return nextAtomState;\n  };\n  var readAtomState = function readAtomState(atom) {\n    var atomState = getAtomState(atom);\n    if (atomState) {\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom && !mountedMap.has(a)) {\n          readAtomState(a);\n        }\n      });\n      if (Array.from(atomState.d).every(function (_ref) {\n        var a = _ref[0],\n          s = _ref[1];\n        return a === atom || getAtomState(a) === s;\n      })) {\n        return atomState;\n      }\n    }\n    var depSet = new Set();\n    var isSync = true;\n    var getter = function getter(a) {\n      depSet.add(a);\n      if (a === atom) {\n        var _aState = getAtomState(a);\n        if (_aState) {\n          return returnAtomValue(_aState);\n        }\n        if (hasInitialValue(a)) {\n          return a.init;\n        }\n        throw new Error('no atom init');\n      }\n      var aState = readAtomState(a);\n      return returnAtomValue(aState);\n    };\n    var controller;\n    var setSelf;\n    var options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if (process.env.NODE_ENV !== \"production\" && !isActuallyWritableAtom(atom)) {\n          console.warn('setSelf function cannot be used with read-only atom');\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = function setSelf() {\n            if (process.env.NODE_ENV !== \"production\" && isSync) {\n              console.warn('setSelf function cannot be called in sync');\n            }\n            if (!isSync) {\n              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n                args[_key] = arguments[_key];\n              }\n              return writeAtom.apply(void 0, [atom].concat(args));\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      var value = atom.read(getter, options);\n      if (value instanceof Promise) {\n        var continuePromise;\n        var promise = new Promise(function (resolve, reject) {\n          var settled = false;\n          value.then(function (v) {\n            if (!settled) {\n              resolvePromise(promise, v);\n              resolve(v);\n            }\n          }, function (e) {\n            if (!settled) {\n              rejectPromise(promise, e);\n              reject(e);\n            }\n          }).finally(function () {\n            if (!settled) {\n              settled = true;\n              setAtomValue(atom, promise, depSet);\n            }\n          });\n          continuePromise = function continuePromise(next) {\n            if (!settled) {\n              settled = true;\n              next.then(function (v) {\n                return resolvePromise(promise, v);\n              }, function (e) {\n                return rejectPromise(promise, e);\n              });\n              resolve(next);\n            }\n          };\n        });\n        promise.status = 'pending';\n        registerCancelPromise(promise, function (next) {\n          var _controller;\n          if (next) {\n            continuePromise(next);\n          }\n          (_controller = controller) == null ? void 0 : _controller.abort();\n        });\n        return setAtomValue(atom, promise, depSet);\n      }\n      return setAtomValue(atom, value, depSet);\n    } catch (error) {\n      return setAtomError(atom, error, depSet);\n    } finally {\n      isSync = false;\n    }\n  };\n  var readAtom = function readAtom(atom) {\n    return returnAtomValue(readAtomState(atom));\n  };\n  var addAtom = function addAtom(atom) {\n    var mounted = mountedMap.get(atom);\n    if (!mounted) {\n      mounted = mountAtom(atom);\n    }\n    return mounted;\n  };\n  var canUnmountAtom = function canUnmountAtom(atom, mounted) {\n    return !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom));\n  };\n  var delAtom = function delAtom(atom) {\n    var mounted = mountedMap.get(atom);\n    if (mounted && canUnmountAtom(atom, mounted)) {\n      unmountAtom(atom);\n    }\n  };\n  var recomputeDependents = function recomputeDependents(atom) {\n    var mounted = mountedMap.get(atom);\n    mounted == null ? void 0 : mounted.t.forEach(function (dependent) {\n      if (dependent !== atom) {\n        var prevAtomState = getAtomState(dependent);\n        var nextAtomState = readAtomState(dependent);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(dependent);\n        }\n      }\n    });\n  };\n  var writeAtomState = function writeAtomState(atom) {\n    var isSync = true;\n    var getter = function getter(a) {\n      return returnAtomValue(readAtomState(a));\n    };\n    var setter = function setter(a) {\n      var r;\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n      if (a === atom) {\n        if (!hasInitialValue(a)) {\n          throw new Error('atom not writable');\n        }\n        var prevAtomState = getAtomState(a);\n        var nextAtomState = setAtomValue(a, args[0]);\n        if (!prevAtomState || !isEqualAtomValue(prevAtomState, nextAtomState)) {\n          recomputeDependents(a);\n        }\n      } else {\n        r = writeAtomState.apply(void 0, [a].concat(args));\n      }\n      if (!isSync) {\n        flushPending();\n      }\n      return r;\n    };\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    var result = atom.write.apply(atom, [getter, setter].concat(args));\n    isSync = false;\n    return result;\n  };\n  var writeAtom = function writeAtom(atom) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    var result = writeAtomState.apply(void 0, [atom].concat(args));\n    flushPending();\n    return result;\n  };\n  var mountAtom = function mountAtom(atom, initialDependent) {\n    var mounted = {\n      t: new Set(initialDependent && [initialDependent]),\n      l: new Set()\n    };\n    mountedMap.set(atom, mounted);\n    if (process.env.NODE_ENV !== \"production\") {\n      mountedAtoms.add(atom);\n    }\n    readAtomState(atom).d.forEach(function (_, a) {\n      var aMounted = mountedMap.get(a);\n      if (aMounted) {\n        aMounted.t.add(atom);\n      } else {\n        if (a !== atom) {\n          mountAtom(a, atom);\n        }\n      }\n    });\n    readAtomState(atom);\n    if (isActuallyWritableAtom(atom) && atom.onMount) {\n      var onUnmount = atom.onMount(function () {\n        for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n          args[_key5] = arguments[_key5];\n        }\n        return writeAtom.apply(void 0, [atom].concat(args));\n      });\n      if (onUnmount) {\n        mounted.u = onUnmount;\n      }\n    }\n    return mounted;\n  };\n  var unmountAtom = function unmountAtom(atom) {\n    var _mountedMap$get;\n    var onUnmount = (_mountedMap$get = mountedMap.get(atom)) == null ? void 0 : _mountedMap$get.u;\n    if (onUnmount) {\n      onUnmount();\n    }\n    mountedMap.delete(atom);\n    if (process.env.NODE_ENV !== \"production\") {\n      mountedAtoms.delete(atom);\n    }\n    var atomState = getAtomState(atom);\n    if (atomState) {\n      if (hasPromiseAtomValue(atomState)) {\n        cancelPromise(atomState.v);\n      }\n      atomState.d.forEach(function (_, a) {\n        if (a !== atom) {\n          var mounted = mountedMap.get(a);\n          if (mounted) {\n            mounted.t.delete(atom);\n            if (canUnmountAtom(a, mounted)) {\n              unmountAtom(a);\n            }\n          }\n        }\n      });\n    } else if (process.env.NODE_ENV !== \"production\") {\n      console.warn('[Bug] could not find atom state to unmount', atom);\n    }\n  };\n  var mountDependencies = function mountDependencies(atom, atomState, prevDependencies) {\n    var depSet = new Set(atomState.d.keys());\n    prevDependencies == null ? void 0 : prevDependencies.forEach(function (_, a) {\n      if (depSet.has(a)) {\n        depSet.delete(a);\n        return;\n      }\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.delete(atom);\n        if (canUnmountAtom(a, mounted)) {\n          unmountAtom(a);\n        }\n      }\n    });\n    depSet.forEach(function (a) {\n      var mounted = mountedMap.get(a);\n      if (mounted) {\n        mounted.t.add(atom);\n      } else if (mountedMap.has(atom)) {\n        mountAtom(a, atom);\n      }\n    });\n  };\n  var flushPending = function flushPending() {\n    while (pendingMap.size) {\n      var pending = Array.from(pendingMap);\n      pendingMap.clear();\n      pending.forEach(function (_ref2) {\n        var atom = _ref2[0],\n          prevAtomState = _ref2[1];\n        var atomState = getAtomState(atom);\n        if (atomState) {\n          if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {\n            mountDependencies(atom, atomState, prevAtomState == null ? void 0 : prevAtomState.d);\n          }\n          var mounted = mountedMap.get(atom);\n          if (mounted && !(prevAtomState && !hasPromiseAtomValue(prevAtomState) && (isEqualAtomValue(prevAtomState, atomState) || isEqualAtomError(prevAtomState, atomState)))) {\n            mounted.l.forEach(function (listener) {\n              return listener();\n            });\n          }\n        } else if (process.env.NODE_ENV !== \"production\") {\n          console.warn('[Bug] no atom state to flush');\n        }\n      });\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      stateListeners.forEach(function (l) {\n        return l();\n      });\n    }\n  };\n  var subscribeAtom = function subscribeAtom(atom, listener) {\n    var mounted = addAtom(atom);\n    flushPending();\n    var listeners = mounted.l;\n    listeners.add(listener);\n    return function () {\n      listeners.delete(listener);\n      delAtom(atom);\n    };\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    return {\n      get: readAtom,\n      set: writeAtom,\n      sub: subscribeAtom,\n      dev_subscribe_state: function dev_subscribe_state(l) {\n        stateListeners.add(l);\n        return function () {\n          stateListeners.delete(l);\n        };\n      },\n      dev_get_mounted_atoms: function dev_get_mounted_atoms() {\n        return mountedAtoms.values();\n      },\n      dev_get_atom_state: function dev_get_atom_state(a) {\n        return atomStateMap.get(a);\n      },\n      dev_get_mounted: function dev_get_mounted(a) {\n        return mountedMap.get(a);\n      },\n      dev_restore_atoms: function dev_restore_atoms(values) {\n        for (var _iterator = _createForOfIteratorHelperLoose(values), _step; !(_step = _iterator()).done;) {\n          var _step$value = _step.value,\n            atom = _step$value[0],\n            value = _step$value[1];\n          if (hasInitialValue(atom)) {\n            setAtomValue(atom, value);\n            recomputeDependents(atom);\n          }\n        }\n        flushPending();\n      }\n    };\n  }\n  return {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom\n  };\n};\nvar defaultStore;\nvar getDefaultStore = function getDefaultStore() {\n  if (!defaultStore) {\n    defaultStore = createStore();\n  }\n  return defaultStore;\n};\n\nexports.atom = atom;\nexports.createStore = createStore;\nexports.getDefaultStore = getDefaultStore;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script"}